        -:    0:Source:../array_test.c
        -:    0:Programs:2
        -:    1:/*
        -:    2: *  Moss Library >>> http://moss.aculo.pl
        -:    3: *
        -:    4: *     /'\_/`\                           
        -:    5: *    /\      \    ___     ____    ____  
        -:    6: *    \ \ \__\ \  / __`\  /',__\  /',__\ 
        -:    7: *     \ \ \_/\ \/\ \L\ \/\__, `\/\__, `\
        -:    8: *      \ \_\\ \_\ \____/\/\____/\/\____/
        -:    9: *       \/_/ \/_/\/___/  \/___/  \/___/ 
        -:   10: *
        -:   11: *  Test file for "Dynamic Array" module.
        -:   12: *
        -:   13: *  This file is part of Moss Library
        -:   14: *  Copyright (c) by sobiemir <sobiemir@aculo.pl>
        -:   15: *
        -:   16: *  This program is free software: you can redistribute it and/or modify
        -:   17: *  it under the terms of the GNU General Public License as published by
        -:   18: *  the Free Software Foundation, either version 3 of the License, or
        -:   19: *  (at your option) any later version.
        -:   20: *
        -:   21: *  This program is distributed in the hope that it will be useful,
        -:   22: *  but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   23: *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   24: *  GNU General Public License for more details.
        -:   25: *
        -:   26: *  You should have received a copy of the GNU General Public License
        -:   27: *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   28: */
        -:   29:
        -:   30:#include <stdio.h>
        -:   31:#include <moss/array.h>
        -:   32:#include <mstest.h>
        -:   33:
        -:   34:/**
        -:   35: * Struktura zawierająca dane używane w funkcjach testujących.
        -:   36: * Dane przekazywane są z funkcji do funkcji.
        -:   37: * Dzięki temu po wystąpieniu błędu i przerwaniu funkcji, pamięć może zostać w prosty sposób zwolniona.
        -:   38: * To właśnie głównie dzięki tej tablicy nie można zmieniać kolejności wywoływania testów.
        -:   39: * Zapobiega wyciekom pamięci.
        -:   40: */
        -:   41:typedef struct MSSTST_ARRAY_DATA
        -:   42:{
        -:   43:	MS_ARRAY *Pointer1;   /* wskaźnik do tablicy alokowanej w pamięci */
        -:   44:	MS_ARRAY *Pointer2;   /* wskaźnik do drugiej tablicy alokowanej w pamięci */
        -:   45:	MS_ARRAY  Local1;     /* wskaźnik do tablicy lokalnej */
        -:   46:	MS_ARRAY  Local2;     /* wskaźnik do drugiej tablicy lokalnej */
        -:   47:}
        -:   48:MSTST_ARRAY_DATA;
        -:   49:
        -:   50:/* Lista przykładowych danych do testowania */
        -:   51:const int LIST[] =
        -:   52:{
        -:   53:	313, 392, 403, 283, 413, 431, 463, 450, 378, 506, 384, 477, 289, 376, 346, 296, 311, 465, 436, 434, 312,
        -:   54:	299, 371, 482, 402, 325, 263, 448, 491, 381, 308, 512, 342, 280, 290, 417, 305, 359, 336, 498, 363, 326,
        -:   55:	368, 508, 279, 453, 318, 406, 271, 319, 293, 354, 374, 323, 459, 454, 507, 467, 440, 292, 470, 306, 409,
        -:   56:	270, 488, 393, 341, 257, 358, 416, 284, 343, 473, 495, 266, 464, 383, 460, 361, 380, 432, 304, 439, 369,
        -:   57:	339, 273, 348, 286, 404, 499, 272, 394, 423, 476, 382, 487, 469, 309, 366, 489, 405, 501, 267, 377, 301,
        -:   58:	397, 462, 412, 461, 347, 320, 474, 269, 294, 276, 445, 370, 388, 492, 430, 437, 481, 315, 387, 365, 256,
        -:   59:	421, 446, 410, 332, 471, 395, 265, 324, 504, 355, 295, 303, 335, 468, 351, 505, 420, 386, 458, 372, 281,
        -:   60:	285, 373, 344, 400, 274, 379, 398, 298, 364, 277, 327, 411, 475, 331, 362, 494, 316, 428, 288, 291, 422,
        -:   61:	391, 457, 287, 300, 338, 390, 389, 350, 456, 407, 356, 375, 441, 401, 333, 275, 502, 509, 511, 349, 337,
        -:   62:	490, 424, 414, 435, 282, 451, 496, 353, 260, 317, 314, 352, 329, 418, 302, 340, 345, 442, 447, 321, 486,
        -:   63:	357, 478, 503, 500, 307, 310, 367, 297, 278, 264, 268, 425, 360, 429, 443, 419, 322, 426, 497, 484, 427,
        -:   64:	466, 433, 334, 479, 483, 261, 455, 510, 444, 262, 415, 449, 452, 472, 328, 493, 396, 399, 259, 438, 330,
        -:   65:	385, 480, 258, 485
        -:   66:};
        -:   67:
        -:   68:/**
        -:   69: * Funkcja wywoływana przy kończeniu testu.
        -:   70: * Zwalnia miejsce przydzielone w pamięci podczas działania programu.
        -:   71: */
        1:   72:void mst_array_teardown( MST_SUITE *suite )
        -:   73:{
        -:   74:	MSTST_ARRAY_DATA *data;
        -:   75:
        1:   76:	if( !suite->Data )
    #####:   77:		return;
        -:   78:
        1:   79:	data = suite->Data;
        -:   80:
        1:   81:	ms_array_free( data->Pointer1 );
        1:   82:	data->Pointer1 = NULL;
        -:   83:
        1:   84:	ms_array_free( data->Pointer2 );
        1:   85:	data->Pointer2 = NULL;
        -:   86:
        1:   87:	ms_array_free( &data->Local1 );
        1:   88:	ms_array_free( &data->Local2 );
        -:   89:}
        -:   90:
        -:   91:/*
        -:   92:======================================================================================================================
        -:   93:------------------------------------------------------------------------------------------------------------------
        -:   94:	TWORZENIE I NISZCZENIE TABLICY
        -:   95:------------------------------------------------------------------------------------------------------------------
        -:   96:======================================================================================================================
        -:   97:*/
        -:   98:
        -:   99:/**
        -:  100: * Test tworzący tablicę na trzy tradycyjne sposoby.
        -:  101: * Pierwszy sposób to zwracanie wskaźnika na funkcję alokowaną do pamięci.
        -:  102: * Drugi sposób to bezpośrednie zwracanie tablicy lokalnej.
        -:  103: * Trzeci sposób to zwykła inicjalizacja, zwracająca kod błędu.
        -:  104: */
        1:  105:int mst_array_create( MST_FUNCTION *info )
        -:  106:{
        -:  107:	MSTST_ARRAY_DATA *data;
        1:  108:	int               ercode = 0;
        -:  109:
        1:  110:	mst_prepare( info );
        1:  111:	data = info->Data;
        -:  112:
        -:  113:	/* tworzenie dwoma sposobami */
        1:  114:	data->Pointer1 = ms_array_alloc( sizeof(long double), 2 );
        1:  115:	data->Local1   = ms_array_return_local( sizeof(long double), 2 );
        -:  116:
        -:  117:	/* inicjalizacja */
        1:  118:	ercode = ms_array_init( &data->Local2, sizeof(long double), 2 );
        1:  119:	mst_assert( ercode == MSEC_OK );
        -:  120:
        -:  121:	/* tworzenie z domyślnym rozmiarem tablicy
        -:  122:	   i tak wszystko przelatuje przez ms_array_init, więc wystarczy sprawdzić
        -:  123:	   wartość tylko w jednej funkcji */
        1:  124:	data->Pointer2 = ms_array_alloc( sizeof(long double), 0 );
        -:  125:
        1:  126:	mst_assert( data->Pointer1 );
        1:  127:	mst_assert( data->Pointer1->Items );
        1:  128:	mst_assert( data->Pointer2 );
        1:  129:	mst_assert( data->Pointer2->Items );
        1:  130:	mst_assert( data->Local1.Items );
        1:  131:	mst_assert( data->Local2.Items );
        -:  132:	
        -:  133:	/* tylko tablice utworzone w pamięci mogą być usuwane w całości */
        1:  134:	mst_assert(  data->Pointer1->Destroy );
        1:  135:	mst_assert(  data->Pointer2->Destroy );
        1:  136:	mst_assert( !data->Local1.Destroy );
        1:  137:	mst_assert( !data->Local2.Destroy );
        -:  138:
        -:  139:	/* taki rozmiar został ustawiony przy tworzeniu */
        1:  140:	mst_assert_uint( data->Pointer1->Capacity, ==, 2 );
        1:  141:	mst_assert_uint( data->Pointer2->Capacity, ==, MSD_ARRAY_DEFAULT_SIZE );
        1:  142:	mst_assert_uint( data->Local1.Capacity,    ==, 2 );
        1:  143:	mst_assert_uint( data->Local2.Capacity,    ==, 2 );
        -:  144:
        -:  145:	/* długość jest 0, gdyż nie ma jeszcze żadnego elementu */
        1:  146:	mst_assert_uint( data->Pointer1->Length, ==, 0 );
        1:  147:	mst_assert_uint( data->Pointer2->Length, ==, 0 );
        1:  148:	mst_assert_uint( data->Local1.Length,    ==, 0 );
        1:  149:	mst_assert_uint( data->Local2.Length,    ==, 0 );
        -:  150:
        -:  151:	/* rozmiar elementu został podany przy tworzeniu, ma być taki sam */
        1:  152:	mst_assert_uint( data->Pointer1->ItemSize, ==, sizeof(long double) );
        1:  153:	mst_assert_uint( data->Pointer2->ItemSize, ==, sizeof(long double) );
        1:  154:	mst_assert_uint( data->Local1.ItemSize,    ==, sizeof(long double) );
        1:  155:	mst_assert_uint( data->Local2.ItemSize,    ==, sizeof(long double) );
        -:  156:
        -:  157:	/* początkowa funkcja odpowiadająca za zwiększanie */
        1:  158:	mst_assert( data->Pointer1->FuncIncrease == MSC_ArrayFunctions.IncMultiply );
        1:  159:	mst_assert( data->Pointer2->FuncIncrease == MSC_ArrayFunctions.IncMultiply );
        1:  160:	mst_assert( data->Local1.FuncIncrease    == MSC_ArrayFunctions.IncMultiply );
        1:  161:	mst_assert( data->Local2.FuncIncrease    == MSC_ArrayFunctions.IncMultiply );
        -:  162:
        -:  163:	/* początkowy modyfikator */
        1:  164:	mst_assert_float( data->Pointer1->Modifier, ==, 2.f );
        1:  165:	mst_assert_float( data->Pointer2->Modifier, ==, 2.f );
        1:  166:	mst_assert_float( data->Local1.Modifier,    ==, 2.f );
        1:  167:	mst_assert_float( data->Local2.Modifier,    ==, 2.f );
        -:  168:
        1:  169:	return MSEC_OK;
        -:  170:}
        -:  171:
        -:  172:/**
        -:  173: * Niszczenie danych tablicy na dwa sposoby.
        -:  174: * Pierwszym jest zwalnianie wszystkich zasobów które przydzieliła funkcja (ms_array_free).
        -:  175: * Drugi sposób to usuwanie elementów z tablicy bez ingerencji w zasoby przydzielone dla tablicy.
        -:  176: */
        1:  177:int mst_array_destroy( MST_FUNCTION *info )
        -:  178:{
        -:  179:	MSTST_ARRAY_DATA *data;
        -:  180:
        1:  181:	mst_prepare( info );
        1:  182:	data = info->Data;
        -:  183:
        1:  184:	mst_assert( data->Pointer1 );
        1:  185:	mst_assert( data->Pointer1->Items );
        1:  186:	mst_assert( data->Local2.Items );
        1:  187:	mst_assert( data->Local1.Items );
        -:  188:
        -:  189:	/* tutaj widać różnicę pomiędzy clear a free */
        1:  190:	ms_array_clear( &data->Local1 );
        1:  191:	mst_assert( data->Local1.Items );
        1:  192:	mst_assert_uint( data->Local1.Length, ==, 0 );
        -:  193:
        1:  194:	ms_array_free( &data->Local1 );
        1:  195:	mst_assert( !data->Local1.Items );
        -:  196:
        -:  197:	/* zwolnij pamięć - funkcja zwalnia wszystko */
        1:  198:	ms_array_free( data->Pointer1 );
        1:  199:	ms_array_free( data->Pointer2 );
        -:  200:	/* nie można sprawdzić danych po usunięciu struktury */
        -:  201:
        1:  202:	ms_array_free( &data->Local2 );
        1:  203:	mst_assert( !data->Local2.Items );
        1:  204:	mst_assert( !data->Local2.Destroy );
        -:  205:
        1:  206:	mst_assert_uint( data->Local2.Capacity, ==, 0 );
        1:  207:	mst_assert_uint( data->Local2.Length,   ==, 0 );
        1:  208:	mst_assert_uint( data->Local2.ItemSize, ==, 0 );
        -:  209:
        1:  210:	data->Pointer1 = NULL;
        1:  211:	data->Pointer2 = NULL;
        -:  212:
        -:  213:	/* próbuj zwolnić coś, co nie prowadzi do niczego */
        1:  214:	ms_array_free( data->Pointer1 );
        -:  215:
        1:  216:	return MSEC_OK;
        -:  217:}
        -:  218:
        -:  219:/*
        -:  220:======================================================================================================================
        -:  221:------------------------------------------------------------------------------------------------------------------
        -:  222:	ZMIANA POJEMNOŚCI
        -:  223:------------------------------------------------------------------------------------------------------------------
        -:  224:======================================================================================================================
        -:  225:*/
        -:  226:
        -:  227:/**
        -:  228: * Standardowa zmiana pojemności tablicy.
        -:  229: * Używana głównie w funkcjach, które dodają do tablicy po jednym elemencie.
        -:  230: * Wykorzystuje odpowiednią funkcję do obliczania nowej pojemności, ustawianą bezpośrednio w strukturze.
        -:  231: */
        1:  232:int mst_array_realloc( MST_FUNCTION *info )
        -:  233:{
        -:  234:	MSTST_ARRAY_DATA *data;
        -:  235:	int               ercode;
        -:  236:	MS_ARRAY         *array;
        -:  237:
        1:  238:	mst_prepare( info );
        1:  239:	data = info->Data;
        1:  240:	mst_assert( !data->Local1.Items );
        -:  241:
        1:  242:	ercode = ms_array_init( &data->Local1, sizeof(int), 2 );
        1:  243:	array  = &data->Local1;
        1:  244:	mst_assert( ercode == MSEC_OK );
        -:  245:
        1:  246:	array->FuncIncrease = MSC_ArrayFunctions.IncPower;
        1:  247:	array->Modifier     = 1.1f;
        -:  248:
        -:  249:	/* 2^1.1 = ~2.14, co daje po zaokrągleniu 2
        -:  250:	 * w takim przypadku do wartości dodawane powinno być 1 */
        1:  251:	ercode = ms_array_realloc( array, 0 );
        1:  252:	mst_assert( ercode == MSEC_OK );
        1:  253:	mst_assert_uint( array->Capacity, ==, 3 );
        -:  254:
        -:  255:	/* 3^2.5 = ~16.83 co daje po zaokrągleniu 16 - zaokrąglanie następuje w dół */
        1:  256:	array->Modifier = 2.57f;
        1:  257:	ercode = ms_array_realloc( array, 0 );
        1:  258:	mst_assert( ercode == MSEC_OK );
        1:  259:	mst_assert_uint( array->Capacity, ==, 16 );
        -:  260:
        1:  261:	array->FuncIncrease = MSC_ArrayFunctions.IncMultiply;
        1:  262:	array->Modifier     = 2.f;
        -:  263:
        -:  264:	/* 16*2 = 32 */
        1:  265:	ercode = ms_array_realloc( array, 0 );
        1:  266:	mst_assert( ercode == MSEC_OK );
        1:  267:	mst_assert_uint( array->Capacity, ==, 32 );
        -:  268:
        -:  269:	/* 32+2 = 34 */
        1:  270:	array->FuncIncrease = MSC_ArrayFunctions.IncAdd;
        1:  271:	ercode = ms_array_realloc( array, 0 );
        1:  272:	mst_assert( ercode == MSEC_OK );
        1:  273:	mst_assert_uint( array->Capacity, ==, 34 );
        -:  274:
        -:  275:	/* zmiana pojemności tablicy do podanej wartości, w tym przypadku powinno być 15 a nie 36 (34+2) */
        1:  276:	ercode = ms_array_realloc( array, 15 );
        1:  277:	mst_assert( ercode == MSEC_OK );
        1:  278:	mst_assert_uint( array->Capacity, ==, 15 );
        -:  279:
        -:  280:	/* symulacja 7 elementów i zmiana pojemności tablicy do podanej wartości
        -:  281:	   powinien wystąpić błąd, ponieważ chcemy za bardzo zmniejszyć pamięć */
        1:  282:	array->Length = 8;
        1:  283:	ercode = ms_array_realloc( array, 7 );
        1:  284:	mst_assert( ercode == MSEC_DATA_OVERFLOW );
        1:  285:	mst_assert_uint( array->Capacity, ==, 15 );
        -:  286:
        -:  287:	/* no ale do 8 powinno się zminejszyć - najmniejsza możliwa aktualnie pojemność */
        1:  288:	ercode = ms_array_realloc( array, 8 );
        1:  289:	mst_assert( ercode == MSEC_OK );
        1:  290:	mst_assert_uint( array->Capacity, ==, 8 );
        -:  291:
        -:  292:	/* dokładne zwiększanie, w tym przypadku spodziewamy się błędu
        -:  293:	   ta technika nie działa na zwykłym realloc, lecz na min_realloc */
        1:  294:	array->FuncIncrease = NULL;
        1:  295:	ercode = ms_array_realloc( array, 0 );
        1:  296:	mst_assert( ercode == MSEC_INVALID_VALUE );
        1:  297:	mst_assert_uint( array->Capacity, ==, 8 );
        -:  298:
        -:  299:	/* zmniejsz do 2 */
        1:  300:	array->Length = 0;
        1:  301:	ercode = ms_array_realloc( array, 2 );
        1:  302:	mst_assert( ercode == MSEC_OK );
        1:  303:	mst_assert_uint( array->Capacity, ==, 2 );
        -:  304:
        1:  305:	return MSEC_OK;
        -:  306:}
        -:  307:
        -:  308:/**
        -:  309: * Zmiana pojemności tablicy do co najmniej podanej wartości minimalnej.
        -:  310: * Ta technika używana jest w przypadku wstawiania kilku elementów do tablicy.
        -:  311: * Pojemność obliczana jest w taki sam sposób jak w przypadku zwykłej ms_array_realloc, jednak
        -:  312: * operacja ta powtarzana jest dopóty, dopóki nie zostanie osiągnięty satysfakcjonujący wynik.
        -:  313: */
        1:  314:int mst_array_realloc_min( MST_FUNCTION *info )
        -:  315:{
        -:  316:	MSTST_ARRAY_DATA *data;
        -:  317:	int               ercode;
        -:  318:	MS_ARRAY         *array;
        -:  319:
        1:  320:	mst_prepare( info );
        1:  321:	data = info->Data;
        -:  322:
        1:  323:	mst_assert( data->Local1.Items );
        1:  324:	array = &data->Local1;
        -:  325:
        -:  326:	/* 2^1.1 = 2.14 ~= 2 (+1 -> gdy lewa jest równa prawej) = 3 */
        1:  327:	array->FuncIncrease = MSC_ArrayFunctions.IncPower;
        1:  328:	array->Modifier     = 1.1f;
        -:  329:
        1:  330:	ercode = ms_array_realloc_min( array, 3 );
        1:  331:	mst_assert( ercode == MSEC_OK );
        1:  332:	mst_assert_uint( array->Capacity, ==, 3 );
        -:  333:
        -:  334:	/* 3^1.5 ~= 5, 5^1.5 ~= 11, 11^1.5 ~= 36 -> STOP, wartość minimalna (20) została osiągnięta */
        1:  335:	array->Modifier = 1.5f;
        1:  336:	ercode = ms_array_realloc_min( array, 20 );
        1:  337:	mst_assert( ercode == MSEC_OK );
        1:  338:	mst_assert_uint( array->Capacity, ==, 36 );
        -:  339:
        -:  340:	/* w tym przypadku wartość nie powinna się zmienić, wystąpiło żądanie mniejszej wartości niż jest
        -:  341:	 * tutaj 0 nie oznacza wartości automatycznej, podawana jest wartość minimalna */
        1:  342:	ercode = ms_array_realloc_min( array, 20 );
        1:  343:	mst_assert( ercode == MSEC_OK );
        1:  344:	mst_assert_uint( array->Capacity, ==, 36 );
        -:  345:
        -:  346:	/* dokładne zwiększanie, powinna być osiągnięta tylko wartość minimalna */
        1:  347:	array->FuncIncrease = NULL;
        1:  348:	ercode = ms_array_realloc_min( array, 256 );
        1:  349:	mst_assert( ercode == MSEC_OK );
        1:  350:	mst_assert_uint( array->Capacity, ==, 256 );
        -:  351:
        -:  352:	/* zmniejsz ilość elementów do 2 */
        1:  353:	ercode = ms_array_realloc( array, 2 );
        1:  354:	mst_assert( ercode == MSEC_OK );
        1:  355:	mst_assert_uint( array->Capacity, ==, 2 );
        -:  356:
        1:  357:	return MSEC_OK;
        -:  358:}
        -:  359:
        -:  360:/*
        -:  361:======================================================================================================================
        -:  362:------------------------------------------------------------------------------------------------------------------
        -:  363:	DODAWANIE ELEMENTÓW
        -:  364:------------------------------------------------------------------------------------------------------------------
        -:  365:======================================================================================================================
        -:  366:*/
        -:  367:
        -:  368:/**
        -:  369: * Test funkcji wstawiającej element do tablicy.
        -:  370: * Wstawia cztery elementy z listy w różne miejsca i porównuje je z oryginałami.
        -:  371: * Funkcja przyjmuje jako parametr wskaźnik na zmienną, która ma być wstawiona.
        -:  372: */
        1:  373:int mst_array_insert_value( MST_FUNCTION *info )
        -:  374:{
        -:  375:	MSTST_ARRAY_DATA *data;
        -:  376:	int               ercode, number;
        -:  377:	MS_ARRAY         *array;
        -:  378:
        1:  379:	mst_prepare( info );
        1:  380:	data = info->Data;
        -:  381:
        1:  382:	mst_assert( data->Local1.Items );
        1:  383:	array = &data->Local1;
        -:  384:
        -:  385:	/* powiększanie dokładne - tyle ile potrzeba w aktualnym momencie */
        1:  386:	array->FuncIncrease = NULL;
        -:  387:
        -:  388:	/* dodaj pierwszy element */
        1:  389:	ercode = ms_array_push_value( array, &LIST[0] );
        1:  390:	mst_assert( ercode == MSEC_OK );
        1:  391:	mst_assert_uint( array->Length,   ==, 1 );
        1:  392:	mst_assert_uint( array->Capacity, ==, 2 );
        -:  393:
        -:  394:	/* dodaj drugi element */
        1:  395:	ercode = ms_array_push_value( array, &LIST[1] ); 
        1:  396:	mst_assert( ercode == MSEC_OK );
        1:  397:	mst_assert_uint( array->Length,   ==, 2 );
        1:  398:	mst_assert_uint( array->Capacity, ==, 2 );
        -:  399:
        -:  400:	/* dodaj trzeci - tutaj powinno nastąpić zwiększenie pojemności tablicy */
        1:  401:	ercode = ms_array_push_value( array, &LIST[2] ); 
        1:  402:	mst_assert( ercode == MSEC_OK );
        1:  403:	mst_assert_uint( array->Length,   ==, 3 );
        1:  404:	mst_assert_uint( array->Capacity, ==, 3 );
        -:  405:
        -:  406:	/* próbuj dodać czwarty poza zakres */
        1:  407:	ercode = ms_array_insert_value( array, 6, &LIST[3] );
        1:  408:	mst_assert( ercode == MSEC_OUT_OF_RANGE );
        1:  409:	mst_assert_uint( array->Length,   ==, 3 );
        1:  410:	mst_assert_uint( array->Capacity, ==, 3 );
        -:  411:
        -:  412:	/* dodaj czwarty zaraz po pierwszym indeksie */
        1:  413:	ercode = ms_array_insert_value( array, 1, &LIST[3] );
        1:  414:	mst_assert( ercode == MSEC_OK );
        1:  415:	mst_assert_uint( array->Length,   ==, 4 );
        1:  416:	mst_assert_uint( array->Capacity, ==, 4 );
        -:  417:
        -:  418:	/* sprawdź czy wartości pobrane będą równe zapisanym
        -:  419:	 * tutaj przetestuj pobieranie z lokalnej tablicy - getl - więc data->Local1 a nie array */
        1:  420:	number = ms_array_getl( data->Local1, int, 0 );
        1:  421:	mst_assert_sint( number, ==, LIST[0] );
        1:  422:	number = ms_array_getl( data->Local1, int, 1 );
        1:  423:	mst_assert_sint( number, ==, LIST[3] );
        1:  424:	number = ms_array_getl( data->Local1, int, 2 );
        1:  425:	mst_assert_sint( number, ==, LIST[1] );
        1:  426:	number = ms_array_getl( data->Local1, int, 3 );
        1:  427:	mst_assert_sint( number, ==, LIST[2] );
        -:  428:
        1:  429:	return MSEC_OK;
        -:  430:}
        -:  431:
        -:  432:/**
        -:  433: * Test funkcji wstawiającej elementy do tablicy.s
        -:  434: * Wstawia całą listę elementów i porównuje je z oryginałami.
        -:  435: * Lista przekazywana do funkcji musi być w formacie standardowej tablicy języka C.
        -:  436: * Wstawiane wartości można ograniczać poprzez uzupełnienie odpowiednich argumentów funkcji.
        -:  437: */
        1:  438:int mst_array_insert_values( MST_FUNCTION *info )
        -:  439:{
        -:  440:	MSTST_ARRAY_DATA *data;
        -:  441:	MS_ARRAY         *array;
        -:  442:
        -:  443:	size_t x, y;
        -:  444:	int    ercode, *items;
        -:  445:
        1:  446:	mst_prepare( info );
        1:  447:	data = info->Data;
        1:  448:	mst_assert( !data->Local2.Items );
        -:  449:
        1:  450:	data->Local2 = ms_array_return_local( sizeof(int), 2 );
        1:  451:	mst_assert( data->Local2.Items );
        1:  452:	array = &data->Local2;
        -:  453:
        -:  454:	/* dodaj pierwszą część
        -:  455:	 * 2 * 2 = 4 * 2 = 8 * 2 = 16 * 2 = 32 * 2 = 64 * 2 = 128 * 2 = 256 */
        1:  456:	ercode = ms_array_push_values( array, LIST, 192 );
        1:  457:	mst_assert( ercode == MSEC_OK );
        1:  458:	mst_assert_uint( array->Length,   ==, 192 );
        1:  459:	mst_assert_uint( array->Capacity, ==, 256 );
        -:  460:
        -:  461:	/* dodaj drugą część */
        1:  462:	ercode = ms_array_insert_values( array, 64, &LIST[192], 32 );
        1:  463:	mst_assert( ercode == MSEC_OK );
        1:  464:	mst_assert_uint( array->Length,   ==, 224 );
        1:  465:	mst_assert_uint( array->Capacity, ==, 256 );
        -:  466:
        -:  467:	/* próbuj wstawić bez rozmiaru */
        1:  468:	ercode = ms_array_push_values( array, LIST, 0 );
        1:  469:	mst_assert( ercode == MSEC_INVALID_ARGUMENT );
        1:  470:	mst_assert_uint( array->Length,   ==, 224 );
        1:  471:	mst_assert_uint( array->Capacity, ==, 256 );
        -:  472:
        -:  473:	/* dodaj trzecią część */
        1:  474:	ercode = ms_array_insert_values( array, 0, &LIST[224], 32 );
        1:  475:	mst_assert( ercode == MSEC_OK );
        1:  476:	mst_assert_uint( array->Length,   ==, 256 );
        1:  477:	mst_assert_uint( array->Capacity, ==, 256 );
        -:  478:
        -:  479:	/* próbuj wstawić poza zakres */
        1:  480:	ercode = ms_array_insert_values( array, 512, LIST, 32 );
        1:  481:	mst_assert( ercode == MSEC_OUT_OF_RANGE );
        1:  482:	mst_assert_uint( array->Length,   ==, 256 );
        1:  483:	mst_assert_uint( array->Capacity, ==, 256 );
        -:  484:
        -:  485:	/* sprawdź poprawność danych */
        1:  486:	items = (int*)array->Items;
       33:  487:	for( y = 224, x = 0; x < 32; ++y, ++x )
       32:  488:		mst_assert_sint( items[x], ==, LIST[y] );
       65:  489:	for( y = 0; y < 64; ++x, ++y )
       64:  490:		mst_assert_sint( items[x], ==, LIST[y] );
       33:  491:	for( y = 192; y < 224; ++x, ++y )
       32:  492:		mst_assert_sint( items[x], ==, LIST[y] );
      129:  493:	for( y = 64; y < 192; ++x, ++y )
      128:  494:		mst_assert_sint( items[x], ==, LIST[y] );
        -:  495:
        1:  496:	return MSEC_OK;
        -:  497:}
        -:  498:
        -:  499:/**
        -:  500: * Test wstawiania tablicy do tablicy.
        -:  501: * Ta wersja funkcji pozwala na wstawienie konkretnego odciętego kawałka tablicy do innej tablicy.
        -:  502: * W przypadku podania zer jako zakresu, kopiowana jest cała tablica.
        -:  503: * Warto zaznaczyć, że wszystkie dane wstawiane są na sam koniec tablicy.
        -:  504: */
        1:  505:int mst_array_join_slice( MST_FUNCTION *info )
        -:  506:{
        -:  507:	MSTST_ARRAY_DATA *data;
        -:  508:
        -:  509:	size_t    x, y;
        -:  510:	int       ercode, *items1, *items2;
        -:  511:	MS_ARRAY *array1, *array2, *array3;
        -:  512:
        1:  513:	mst_prepare( info );
        1:  514:	data = info->Data;
        -:  515:
        1:  516:	mst_assert(  data->Local2.Items );
        1:  517:	mst_assert( !data->Pointer1 );
        1:  518:	mst_assert( !data->Pointer2 );
        1:  519:	array1 = &data->Local2;
        -:  520:
        1:  521:	array2 = data->Pointer1 = ms_array_alloc( array1->ItemSize, 64 );
        1:  522:	mst_assert( array2->Items );
        -:  523:
        1:  524:	array3 = data->Pointer2 = ms_array_alloc( array1->ItemSize * 2, 64 );
        1:  525:	mst_assert( array3->Items );
        -:  526:
        -:  527:	/* dodaj wartości z podanego zakresu - idealnie do 64 elementów
        -:  528:	 * wielkość tablicy nie powinna się zmienic */
        1:  529:	ercode = ms_array_join_slice( array2, array1, 64, 64 );
        1:  530:	mst_assert( ercode == MSEC_OK );
        1:  531:	mst_assert_uint( array2->Length,   ==, 64 );
        1:  532:	mst_assert_uint( array2->Capacity, ==, 64 );
        -:  533:
        -:  534:	/* dodaj wartości z podanego zakresu - kopiuj do końca */
        1:  535:	ercode = ms_array_join_slice( array2, array1, 192, 0 );
        1:  536:	mst_assert( ercode == MSEC_OK );
        -:  537:
        1:  538:	mst_assert_uint( array2->Length,   ==, 128 );
        1:  539:	mst_assert_uint( array2->Capacity, ==, 128 );
        -:  540:
        -:  541:	/* błąd - indeks poza zakresem */
        1:  542:	ercode = ms_array_join_slice( array2, array1, 192, 256 );
        1:  543:	mst_assert( ercode == MSEC_OUT_OF_RANGE );
        1:  544:	mst_assert_uint( array2->Length,   ==, 128 );
        1:  545:	mst_assert_uint( array2->Capacity, ==, 128 );
        -:  546:
        -:  547:	/* próbuj skopiować wartości do tablicy z innymi rozmiarami elementów */
        1:  548:	ercode = ms_array_join( array3, array2 );
        1:  549:	mst_assert( ercode == MSEC_INVALID_ARGUMENT );
        1:  550:	mst_assert_uint( array3->Length,   ==, 0 );
        1:  551:	mst_assert_uint( array3->Capacity, ==, 64 );
        -:  552:
        -:  553:	/* sprawdź czy w tablicy znajdują się poprawne elementy */
        1:  554:	items2 = (int*)array2->Items;
        1:  555:	items1 = (int*)array1->Items;
       65:  556:	for( x = 0, y = 64; y < 128; ++x, ++y )
       64:  557:		mst_assert_sint( items2[x], ==, items1[y] );
       65:  558:	for( y = 192; y < 256; ++x, ++y )
       64:  559:		mst_assert_sint( items2[x], ==, items1[y] );
        -:  560:
        1:  561:	return MSEC_OK;
        -:  562:}
        -:  563:
        -:  564:/**
        -:  565: * Drugi test wstawiania tablicy do tablicy.
        -:  566: * Ta wersja funkcji pozwala na wstawienie do tablicy elementów z innej tablicy spoza podanego zakresu.
        -:  567: * W przypadku 256 elementów i ustawieniu zakresu 128 elementów od 64 indeksu, skopiowane zostaną wartości 
        -:  568: * od 0-64 oraz od 192 do 256.
        -:  569: * Zakres oznaczany jest przez indeks początkowy i ilość elementów do skopiowania.
        -:  570: */
        1:  571:int mst_array_join_slice_inverse( MST_FUNCTION *info )
        -:  572:{
        -:  573:	MSTST_ARRAY_DATA *data;
        -:  574:
        -:  575:	size_t    x, y;
        -:  576:	int       ercode, *items1, *items2;
        -:  577:	MS_ARRAY *array1, *array2, *array3;
        -:  578:
        1:  579:	mst_prepare( info );
        1:  580:	data = info->Data;
        1:  581:	mst_assert( data->Local2.Items );
        1:  582:	mst_assert( data->Pointer1 );
        1:  583:	mst_assert( data->Pointer2 );
        1:  584:	array1 = &data->Local2;
        -:  585:
        -:  586:	/* wyczyść poprzednio uzupełnianą tablicę
        -:  587:	 * przy okazji sprawdź, czy czyszczenie działa w porządku */
        1:  588:	array2 = data->Pointer1;
        1:  589:	ms_array_clear( array2 );
        1:  590:	mst_assert( array2->Items );
        1:  591:	mst_assert( array2->Destroy );
        -:  592:
        1:  593:	mst_assert_uint( array2->ItemSize, ==, sizeof(int) );
        1:  594:	mst_assert_uint( array2->Length,   ==, 0 );
        1:  595:	mst_assert_uint( array2->Capacity, ==, 128 );
        -:  596:
        1:  597:	array3 = data->Pointer2;
        1:  598:	mst_assert_uint( array3->ItemSize, ==, sizeof(int) * 2 );
        -:  599:
        -:  600:	/* dodaj wartości z innej tablicy z podanego zakresu (0:64, 192:256) */
        1:  601:	ercode = ms_array_join_slice_inverse( array2, array1, 64, 128 );
        1:  602:	mst_assert( ercode == MSEC_OK );
        1:  603:	mst_assert_uint( array2->Length,   ==, 128 );
        1:  604:	mst_assert_uint( array2->Capacity, ==, 128 );
        -:  605:
        -:  606:	/* próbuj dodać wartości spoza zakresu (0-64, 320-OVERFLOW) */
        1:  607:	ercode = ms_array_join_slice_inverse( array2, array1, 64, 256 );
        1:  608:	mst_assert( ercode == MSEC_OUT_OF_RANGE );
        1:  609:	mst_assert_uint( array2->Length,   ==, 128 );
        1:  610:	mst_assert_uint( array2->Capacity, ==, 128 );
        -:  611:
        -:  612:	/* zakres od wartości do końca (0:128, 256:256) */
        1:  613:	ercode = ms_array_join_slice_inverse( array2, array1, 128, 0 );
        1:  614:	mst_assert( ercode == MSEC_OK );
        1:  615:	mst_assert_uint( array2->Length,   ==, 256 );
        1:  616:	mst_assert_uint( array2->Capacity, ==, 256 );
        -:  617:
        -:  618:	/* próbuj skopiować wartości do tablicy z innymi rozmiarami elementów */
        1:  619:	ercode = ms_array_join_slice_inverse( array3, array2, 128, 64 );
        1:  620:	mst_assert( ercode == MSEC_INVALID_ARGUMENT );
        1:  621:	mst_assert_uint( array3->Length,   ==, 0 );
        1:  622:	mst_assert_uint( array3->Capacity, ==, 64 );
        -:  623:
        -:  624:	/* sprawdź czy w tablicy znajdują się poprawne elementy */
        1:  625:	items1 = (int*)array1->Items;
        1:  626:	items2 = (int*)array2->Items;
       65:  627:	for( x = 0, y = 0; y < 64; ++x, ++y )
       64:  628:		mst_assert_sint( items2[x], ==, items1[y] );
       65:  629:	for( y = 192; y < 256; ++x, ++y )
       64:  630:		mst_assert_sint( items2[x], ==, items1[y] );
      129:  631:	for( y = 0; y < 128; ++x, ++y )
      128:  632:		mst_assert_sint( items2[x], ==, items1[y] );
        -:  633:
        1:  634:	return MSEC_OK;
        -:  635:}
        -:  636:
        -:  637:/*
        -:  638:======================================================================================================================
        -:  639:------------------------------------------------------------------------------------------------------------------
        -:  640:	KOPIOWANIE TABLICY
        -:  641:------------------------------------------------------------------------------------------------------------------
        -:  642:======================================================================================================================
        -:  643:*/
        -:  644:
        -:  645:/**
        -:  646: * Kopiowanie tablicy dwoma sposobami.
        -:  647: * Pierwszy sposób to kopiowanie do istniejącej już w pamięci tablicy (ms_array_copy).
        -:  648: * Drugi sposób to kopiowanie do nowej tablicy i zwrócenie wskazania na nią (ms_array_copy_alloc).
        -:  649: */
        1:  650:int mst_array_copy( MST_FUNCTION *info )
        -:  651:{
        -:  652:	MSTST_ARRAY_DATA *data;
        -:  653:
        -:  654:	size_t    iter;
        -:  655:	int       ercode;
        -:  656:	MS_ARRAY *array1, *array2, *array3;
        -:  657:
        1:  658:	mst_prepare( info );
        1:  659:	data = info->Data;
        1:  660:	mst_assert( data->Local2.Items );
        1:  661:	mst_assert( data->Local1.Items );
        1:  662:	mst_assert( data->Pointer2 );
        -:  663:
        1:  664:	array1 = &data->Local2;
        1:  665:	array2 = &data->Local1;
        -:  666:
        -:  667:	/* wyczyść tablice */
        1:  668:	ms_array_free( array2 );
        1:  669:	mst_assert( !array2->Items );
        -:  670:
        -:  671:	/* kopiuj wartości */
        1:  672:	ercode = ms_array_copy( array2, array1 );
        1:  673:	mst_assert( ercode == MSEC_OK );
        -:  674:
        -:  675:	/* obie tablice są lokalne, więc o polu Destroy ustawionym na false nie ma mowy */
        1:  676:	mst_assert_uint( array1->Capacity, ==, array2->Capacity );
        1:  677:	mst_assert_uint( array1->Length,   ==, array2->Length );
        -:  678:
        1:  679:	mst_assert( array1->Destroy == array2->Destroy );
        1:  680:	mst_assert( array1->Items != array2->Items );
        -:  681:
        -:  682:	/* sprawdź czy elementy są takie same */
      257:  683:	for( iter = 0; iter < array1->Length; ++iter )
      256:  684:		mst_assert_uint( ms_array_get(array1, int, iter), ==, ms_array_get(array2, int, iter) );
        -:  685:
        -:  686:	/* tą tablicę należy usunąć gdyż jest to wskaźnik - inaczej mogą być wycieki pamięci */
        1:  687:	ms_array_free( data->Pointer2 );
        -:  688:
        -:  689:	/* a teraz kopiuj zwracając wskaźnik do nowej tablicy */
        1:  690:	array3 = data->Pointer2 = ms_array_copy_alloc( array1 );
        -:  691:
        -:  692:	/* przyrównaj do drugiej tablicy, wartości muszą być te same */
        1:  693:	mst_assert( array3 );
        1:  694:	mst_assert_uint( array2->Capacity, ==, array3->Capacity );
        1:  695:	mst_assert_uint( array2->Length,   ==, array3->Length );
        -:  696:
        -:  697:	/* oprócz destroy, pamięć przydzielona na strukturę musi być zawsze niszczona
        -:  698:	 * więc w tym przypadku array3 musi mieć pole Destroy ustawione zawsze na true */
        1:  699:	mst_assert( array2->Destroy != array3->Destroy );
        1:  700:	mst_assert( array2->Items != array3->Items );
        -:  701:
        -:  702:	/* sprawdź czy elementy są takie same */
      257:  703:	for( iter = 0; iter < array2->Length; ++iter )
      256:  704:		mst_assert_sint( ms_array_get(array2, int, iter), ==, ms_array_get(array3, int, iter) );
        -:  705:
        1:  706:	return MSEC_OK;
        -:  707:}
        -:  708:
        -:  709:/*
        -:  710:======================================================================================================================
        -:  711:------------------------------------------------------------------------------------------------------------------
        -:  712:	USUWANIE ELEMENTÓW
        -:  713:------------------------------------------------------------------------------------------------------------------
        -:  714:======================================================================================================================
        -:  715:*/
        -:  716:
        -:  717:/**
        -:  718: * Test usuwania elementów tablicy znajdujących się poza podanym zakresem.
        -:  719: * Zmiany wykonane przez funkcje są trwałe, kopia tablicy nie jest tworzona.
        -:  720: * Aby zrobić kopię z podanych wartości należy użyć ms_array_join_slice na nowej tablicy.
        -:  721: */
        1:  722:int mst_array_slice( MST_FUNCTION *info )
        -:  723:{
        -:  724:	MSTST_ARRAY_DATA *data;
        -:  725:
        -:  726:	size_t    x, y;
        -:  727:	int       ercode;
        -:  728:	MS_ARRAY *array;
        -:  729:
        1:  730:	mst_prepare( info );
        1:  731:	data = info->Data;
        1:  732:	mst_assert( data->Pointer2 );
        1:  733:	mst_assert( data->Pointer2->Items );
        1:  734:	mst_assert( data->Local2.Items );
        1:  735:	array = data->Pointer2;
        -:  736:
        -:  737:	/* pozostaw elementy od 32 do 160 -> 128 elementów po indeksie 32 */
        1:  738:	ercode = ms_array_slice( array, 32, 128 );
        1:  739:	mst_assert( ercode == MSEC_OK );
        1:  740:	mst_assert_uint( array->Length,   ==, 128 );
        1:  741:	mst_assert_uint( array->Capacity, ==, 256 );
        -:  742:
        -:  743:	/* sprawdź czy wartości się zgadzają */
      129:  744:	for( x = 0, y = 32; x < 128; ++y, ++x )
      128:  745:		mst_assert_sint( ms_array_get(array, int, x), ==, ms_array_getl(data->Local2, int, y) );
        -:  746:
        -:  747:	/* obcinanie poza zakres (32:160, elementów jest 128) */
        1:  748:	ercode = ms_array_slice( array, 32, 128 );
        1:  749:	mst_assert( ercode == MSEC_OUT_OF_RANGE );
        1:  750:	mst_assert_uint( array->Length,   ==, 128 );
        1:  751:	mst_assert_uint( array->Capacity, ==, 256 );
        -:  752:
        -:  753:	/* obcinanie od indeksu do końca */
        1:  754:	ercode = ms_array_slice( array, 64, 0 );
        1:  755:	mst_assert( ercode == MSEC_OK );
        1:  756:	mst_assert_uint( array->Length,   ==, 64 );
        1:  757:	mst_assert_uint( array->Capacity, ==, 256 );
        -:  758:
        -:  759:	/* sprawdź czy wartości się zgadzają po przesunięciu */
       65:  760:	for( x = 0, y = 96; x < 64; ++y, ++x )
       64:  761:		mst_assert_sint( ms_array_get(array, int, x), ==, ms_array_getl(data->Local2, int, y) );
        -:  762:
        -:  763:	/* obcinanie od indeksu od początku - bez przesuwania elementów w pamięci */
        1:  764:	ercode = ms_array_slice( array, 0, 32 );
        1:  765:	mst_assert( ercode == MSEC_OK );
        1:  766:	mst_assert_uint( array->Length,   ==, 32 );
        1:  767:	mst_assert_uint( array->Capacity, ==, 256 );
        -:  768:
        -:  769:	/* sprawdź czy wartości się zgadzają po usunięciu ogona od podanego indeksu */
       33:  770:	for( x = 0, y = 96; x < 32; ++y, ++x )
       32:  771:		mst_assert_sint( ms_array_get(array, int, x), ==, ms_array_getl(data->Local2, int, y) );
        -:  772:
        -:  773:	/* wyczyść tablicę nie zwalniając jednak pamięci przechowującej elementy */
        1:  774:	ms_array_clear( array );
        1:  775:	mst_assert_uint( array->Length, ==, 0 );
        1:  776:	mst_assert( array->Items );
        -:  777:
        -:  778:	/* próbuj obciąć pustą tablicę */
        1:  779:	ercode = ms_array_slice( array, 32, 128 );
        1:  780:	mst_assert( ercode == MSEC_INVALID_ARGUMENT );
        1:  781:	mst_assert_uint( array->Length,   ==, 0 );
        1:  782:	mst_assert_uint( array->Capacity, ==, 256 );
        -:  783:
        1:  784:	return MSEC_OK;
        -:  785:}
        -:  786:
        -:  787:/**
        -:  788: * Test usuwania elementów tablicy z podanego zakresu.
        -:  789: * Aliasem tej funkcji jest makro o nazwie ms_array_slice_inverse.
        -:  790: * Zmiany wykonywane na tablicy są trwałe.
        -:  791: */
        1:  792:int mst_array_remove_range( MST_FUNCTION *info )
        -:  793:{
        -:  794:	MSTST_ARRAY_DATA *data;
        -:  795:
        -:  796:	size_t    x, y;
        -:  797:	int       ercode;
        -:  798:	MS_ARRAY *array;
        -:  799:
        1:  800:	mst_prepare( info );
        1:  801:	data = info->Data;
        1:  802:	mst_assert( data->Local1.Items );
        1:  803:	mst_assert( data->Local2.Items );
        1:  804:	array = &data->Local1;
        -:  805:
        -:  806:	/* usuń elementy od 64 do 128 (64+64) */
        1:  807:	ercode = ms_array_remove_range( array, 64, 64 );
        1:  808:	mst_assert( ercode == MSEC_OK );
        1:  809:	mst_assert_uint( array->Length,   ==, 192 );
        1:  810:	mst_assert_uint( array->Capacity, ==, 256 );
        -:  811:
        -:  812:	/* sprawdź czy wartości się zgadzają */
       65:  813:	for( x = 0, y = 0; x < 64; ++y, ++x )
       64:  814:		mst_assert_sint( ms_array_get(array, int, x), ==, ms_array_getl(data->Local2, int, y) );
      129:  815:	for( y = 128; y < 256; ++y, ++x )
      128:  816:		mst_assert_sint( ms_array_get(array, int, x), ==, ms_array_getl(data->Local2, int, y) );
        -:  817:
        -:  818:	/* usuwaj od indeksu 128 do końca - usuwanie bez przesuwania */
        1:  819:	ercode = ms_array_remove_range( array, 128, 0 );
        1:  820:	mst_assert( ercode == MSEC_OK );
        1:  821:	mst_assert_uint( array->Length,   ==, 128 );
        1:  822:	mst_assert_uint( array->Capacity, ==, 256 );
        -:  823:
        -:  824:	/* próbuj usunąć spoza zakresu */
        1:  825:	ercode = ms_array_remove_range( array, 128, 128 );
        1:  826:	mst_assert( ercode == MSEC_OUT_OF_RANGE );
        1:  827:	mst_assert_uint( array->Length,   ==, 128 );
        1:  828:	mst_assert_uint( array->Capacity, ==, 256 );
        -:  829:
        -:  830:	/* wyczyść */
        1:  831:	ms_array_clear( array );
        1:  832:	mst_assert_uint( array->Length, ==, 0 );
        1:  833:	mst_assert( array->Items );
        -:  834:
        -:  835:	/* próbuj teraz coś usunąć */
        1:  836:	ercode = ms_array_remove_range( array, 0, 5 );
        1:  837:	mst_assert( ercode == MSEC_INVALID_ARGUMENT );
        1:  838:	mst_assert_uint( array->Length,   ==, 0 );
        1:  839:	mst_assert_uint( array->Capacity, ==, 256 );
        -:  840:
        1:  841:	return MSEC_OK;
        -:  842:}
        -:  843:
        -:  844:/**
        -:  845: * Test usuwania elementu tablicy o podanym indeksie.
        -:  846: * Istnieje alias do wywołania funkcji, który usuwa ostani element tablicy (ms_array_remove_last).
        -:  847: * Funkcja nie zmniejsza pojemności tablicy, aby to zrobić należy wywołać funkcję ms_array_realloc.
        -:  848: */
        1:  849:int mst_array_remove( MST_FUNCTION *info )
        -:  850:{
        -:  851:	MSTST_ARRAY_DATA *data;
        -:  852:
        -:  853:	int       ercode;
        -:  854:	MS_ARRAY *array1, *array2;
        -:  855:
        1:  856:	mst_prepare( info );
        1:  857:	data = info->Data;
        1:  858:	mst_assert( data->Pointer1 );
        1:  859:	mst_assert( data->Pointer2 );
        1:  860:	mst_assert( data->Pointer1->Items );
        1:  861:	mst_assert( data->Pointer2->Items );
        1:  862:	mst_assert_uint( data->Pointer1->Capacity, ==, 256 );
        1:  863:	array1 = data->Pointer1;
        -:  864:
        1:  865:	ms_array_free( data->Pointer2 );
        -:  866:
        -:  867:	/* utwórz kopię tablicy aby można było porównać wyniki */
        1:  868:	data->Pointer2 = ms_array_copy_alloc( data->Pointer1 );
        1:  869:	mst_assert( data->Pointer2 );
        1:  870:	mst_assert( data->Pointer2->Items );
        1:  871:	array2 = data->Pointer2;
        -:  872:
        -:  873:	/* sprawdź czy ten konkretny element jest taki sam - musi być, skoro tablica była kopiowana */
        1:  874:	mst_assert_sint( ms_array_get(array1, int, 64), ==, ms_array_get(array2, int, 64) );
        -:  875:
        -:  876:	/* usuń ostatni element */
        1:  877:	ercode = ms_array_remove_last( array1 );
        1:  878:	mst_assert( ercode == MSEC_OK );
        1:  879:	mst_assert_uint( array1->Length,   ==, 255 );
        1:  880:	mst_assert_uint( array1->Capacity, ==, 256 );
        -:  881:
        -:  882:	/* nadal musi być taki sam, skoro usuwany był tylko ostatni element */
        1:  883:	mst_assert_sint( ms_array_get(array1, int, 64), ==, ms_array_get(array2, int, 64) );
        -:  884:
        -:  885:	/* usuń z wybranej pozycji */
        1:  886:	ercode = ms_array_remove( array1, 64 );
        1:  887:	mst_assert( ercode == MSEC_OK );
        1:  888:	mst_assert_uint( array1->Length,   ==, 254 );
        1:  889:	mst_assert_uint( array1->Capacity, ==, 256 );
        -:  890:
        -:  891:	/* sprawdź czy element został usunięty poprawnie */
        1:  892:	mst_assert_sint( ms_array_get(array1, int, 64), !=, ms_array_get(array2, int, 64) );
        1:  893:	mst_assert_sint( ms_array_get(array1, int, 64), ==, ms_array_get(array2, int, 65) );
        -:  894:
        -:  895:	/* próbuj usunąć spoza zakresu */
        1:  896:	ercode = ms_array_remove( array1, 255 );
        1:  897:	mst_assert( ercode == MSEC_OUT_OF_RANGE );
        1:  898:	mst_assert_uint( array1->Length,   ==, 254 );
        1:  899:	mst_assert_uint( array1->Capacity, ==, 256 );
        -:  900:
        -:  901:	/* wyczyść tablicę */
        1:  902:	ms_array_clear( array1 );
        1:  903:	mst_assert( array1->Items );
        1:  904:	mst_assert_uint( array1->Length,   ==, 0 );
        1:  905:	mst_assert_uint( array1->Capacity, ==, 256 );
        -:  906:
        -:  907:	/* próbuj usunąć z pustej tablicy */
        1:  908:	ercode = ms_array_remove( array1, 255 );
        1:  909:	mst_assert( ercode == MSEC_INVALID_ARGUMENT );
        1:  910:	mst_assert_uint( array1->Length,   ==, 0 );
        1:  911:	mst_assert_uint( array1->Capacity, ==, 256 );
        -:  912:
        1:  913:	return MSEC_OK;
        -:  914:}
        -:  915:
        -:  916:/*
        -:  917:======================================================================================================================
        -:  918:------------------------------------------------------------------------------------------------------------------
        -:  919:	TESTY FUNKCJI BAZOWYCH
        -:  920:------------------------------------------------------------------------------------------------------------------
        -:  921:======================================================================================================================
        -:  922:*/
        -:  923:
        -:  924:/**
        -:  925: * Test tworzenia tablicy o wybranym typie.
        -:  926: * Tutaj typem jest typ standardowy - wskaźnik na typ void.
        -:  927: * Jest to funkcja bazowa, co oznacza że istnie makro, pozwalające na rozszerzenie jej dla innych typów.
        -:  928: */
        1:  929:int mst_array_base_return( MST_FUNCTION *info )
        -:  930:{
        -:  931:	MSTST_ARRAY_DATA *data;
        -:  932:
        1:  933:	mst_prepare( info );
        1:  934:	data = info->Data;
        1:  935:	mst_assert( data->Local1.Items );
        -:  936:
        -:  937:	/* usuń dane */
        1:  938:	ms_array_free( &data->Local1 );
        1:  939:	mst_assert( !data->Local1.Items );
        -:  940:
        1:  941:	data->Local1 = ms_array_return( 2 );
        1:  942:	mst_assert( data->Local1.Items );
        -:  943:
        -:  944:	/* sprawdź podstawwe pola struktury */
        1:  945:	mst_assert( !data->Local1.Destroy );
        1:  946:	mst_assert_uint( data->Local1.Capacity, ==, 2 );
        1:  947:	mst_assert_uint( data->Local1.Length,   ==, 0 );
        1:  948:	mst_assert_uint( data->Local1.ItemSize, ==, (sizeof *data->Local1.Items) );
        -:  949:
        1:  950:	return MSEC_OK;
        -:  951:}
        -:  952:
        -:  953:/**
        -:  954: * Test wstawiania elementu o wybranym typie do tablicy.
        -:  955: * Wstawianie wielu elementów odbywa się normalnie, a więc funkcją ms_array_insert_values.
        -:  956: * Tutaj typem jest typ standardowy - wskaźnik na typ void.
        -:  957: * Jest to funkcja bazowa, co oznacza że istnie makro, pozwalające na rozszerzenie jej dla innych typów.
        -:  958: */
        1:  959:int mst_array_base_insert( MST_FUNCTION *info )
        -:  960:{
        -:  961:	MSTST_ARRAY_DATA *data;
        -:  962:	MS_ARRAY         *array;
        -:  963:	int               ercode;
        -:  964:
        1:  965:	mst_prepare( info );
        1:  966:	data = info->Data;
        1:  967:	mst_assert( data->Local1.Items );
        1:  968:	array = &data->Local1;
        -:  969:
        -:  970:	/* powiększanie dokładne - tyle ile potrzeba w aktualnym momencie */
        1:  971:	array->FuncIncrease = NULL;
        -:  972:
        -:  973:	/* dodaj pierwszy element */
        1:  974:	ercode = ms_array_push( array, &LIST[0] );
        1:  975:	mst_assert( ercode == MSEC_OK );
        1:  976:	mst_assert_uint( array->Length,   ==, 1 );
        1:  977:	mst_assert_uint( array->Capacity, ==, 2 );
        -:  978:
        -:  979:	/* dodaj drugi element */
        1:  980:	ercode = ms_array_insert( array, 0, &LIST[1] );
        1:  981:	mst_assert( ercode == MSEC_OK );
        1:  982:	mst_assert_uint( array->Length,   ==, 2 );
        1:  983:	mst_assert_uint( array->Capacity, ==, 2 );
        -:  984:
        -:  985:	/* dodaj trzeci element - tutaj powinno nastąpić zwiększenie pojemności tablicy */
        1:  986:	ercode = ms_array_insert( array, 1, &LIST[2] );
        1:  987:	mst_assert( ercode == MSEC_OK );
        1:  988:	mst_assert_uint( array->Length,   ==, 3 );
        1:  989:	mst_assert_uint( array->Capacity, ==, 3 );
        -:  990:
        -:  991:	/* dodaj czwarty element - tutaj również zwiększenie tablicy */
        1:  992:	ercode = ms_array_insert( array, 1, &LIST[3] );
        1:  993:	mst_assert( ercode == MSEC_OK );
        1:  994:	mst_assert_uint( array->Length,   ==, 4 );
        1:  995:	mst_assert_uint( array->Capacity, ==, 4 );
        -:  996:
        -:  997:	/* dodaj piąty - powinien wystąpić bład, próba dodania elementu poza zakres */
        1:  998:	ercode = ms_array_insert( array, 6, &LIST[1] );
        1:  999:	mst_assert( ercode == MSEC_OUT_OF_RANGE );
        1: 1000:	mst_assert_uint( array->Length,   ==, 4 );
        1: 1001:	mst_assert_uint( array->Capacity, ==, 4 );
        -: 1002:
        -: 1003:	/* sprawdź czy wartości pobrane będą równe zapisanym */
        1: 1004:	mst_assert( array->Items[0] == &LIST[1] );
        1: 1005:	mst_assert( array->Items[1] == &LIST[3] );
        1: 1006:	mst_assert( array->Items[2] == &LIST[2] );
        1: 1007:	mst_assert( array->Items[3] == &LIST[0] );
        -: 1008:
        1: 1009:	return MSEC_OK;
        -: 1010:}
        -: 1011:
        -: 1012:/**
        -: 1013: * Test kopiowania tablicy o wybranym typie do tablicy lokalnej.
        -: 1014: * Kopiowanie do tablicy alokowanej w pamięci odbywa się normalnie, a więc funkcją ms_array_copy_alloc.
        -: 1015: * Tutaj typem jest typ standardowy - wskaźnik na typ void.
        -: 1016: * Jest to funkcja bazowa, co oznacza że istnie makro, pozwalające na rozszerzenie jej dla innych typów.
        -: 1017: */
        1: 1018:int mst_array_base_copy_return( MST_FUNCTION *info )
        -: 1019:{
        -: 1020:	MSTST_ARRAY_DATA *data;
        -: 1021:	MS_ARRAY         *array1, *array2;
        -: 1022:	size_t            iter;
        -: 1023:
        1: 1024:	mst_prepare( info );
        1: 1025:	data = info->Data;
        1: 1026:	mst_assert( data->Local1.Items );
        1: 1027:	mst_assert( data->Local2.Items );
        1: 1028:	array1 = &data->Local1;
        -: 1029:
        -: 1030:	/* wyczyść tablicę ze starych śmieci */
        1: 1031:	ms_array_free( &data->Local2 );
        1: 1032:	mst_assert( !data->Local2.Items );
        -: 1033:
        1: 1034:	data->Local2 = ms_array_copy_return( array1 );
        1: 1035:	mst_assert( data->Local2.Items );
        1: 1036:	array2 = &data->Local2;
        -: 1037:
        1: 1038:	mst_assert_uint( array1->Capacity, ==, array2->Capacity );
        1: 1039:	mst_assert_uint( array1->Length,   ==, array2->Length );
        -: 1040:
        -: 1041:	/* w tym momencie destroy powinien być taki sam, jednak w przypadku kopiowania
        -: 1042:	 * z wskaźnika powinien być inny */
        1: 1043:	mst_assert( array1->Destroy == array2->Destroy );
        1: 1044:	mst_assert( array1->Items != array2->Items );
        -: 1045:
        -: 1046:	/* sprawdź czy elementy są takie same */
        5: 1047:	for( iter = 0; iter < array1->Length; ++iter )
        4: 1048:		mst_assert( ms_array_get(array1, int, iter) == ms_array_get(array2, int, iter) );
        -: 1049:
        1: 1050:	mst_assert( data->Pointer1->Items );
        1: 1051:	ms_array_free( data->Pointer1 );
        -: 1052:
        -: 1053:	/* no to teraz kopiuj tablicę starą metodą */
        1: 1054:	data->Pointer1 = ms_array_copy_alloc( array1 );
        -: 1055:
        -: 1056:	/* wyczyść drugą tablicę */
        1: 1057:	ms_array_free( array2 );
        1: 1058:	mst_assert( !array2->Items );
        1: 1059:	mst_assert_uint( array2->Length, ==, 0 );
        -: 1060:
        -: 1061:	/* kopiuj nową metodą */
        1: 1062:	data->Local2 = ms_array_copy_return( data->Pointer1 );
        1: 1063:	mst_assert( data->Local2.Items );
        1: 1064:	array2 = &data->Local2;
        -: 1065:
        -: 1066:	/* i sprawdź to nieszczęsne Destroy */
        1: 1067:	mst_assert( data->Pointer1->Destroy != array2->Destroy );
        -: 1068:
        1: 1069:	return MSEC_OK;
        -: 1070:}
        -: 1071:
        -: 1072:/*
        -: 1073:======================================================================================================================
        -: 1074:------------------------------------------------------------------------------------------------------------------
        -: 1075:	URUCHAMIANIE TESTÓW
        -: 1076:------------------------------------------------------------------------------------------------------------------
        -: 1077:======================================================================================================================
        -: 1078:*/
        -: 1079:
        -: 1080:/**
        -: 1081: * Opisy funkcji testujących.
        -: 1082: * Wyświetlane są zaraz pod nazwą funkcji podczas testowania.
        -: 1083: * Uporzadkowane w kolejności rozmieszczenia funkcji w liście.
        -: 1084: */
        -: 1085:#define FUNC_DESC_01 "Create array by alloc, init and return functions."
        -: 1086:#define FUNC_DESC_02 "Destroy array, created by alloc and init or return."
        -: 1087:#define FUNC_DESC_03 "Change array capacity by using simple realloc version."
        -: 1088:#define FUNC_DESC_04 "Change array capacity by using minimum realloc version."
        -: 1089:#define FUNC_DESC_05 "Insert single value into array at given index."
        -: 1090:#define FUNC_DESC_06 "Insert values from table into array at given index."
        -: 1091:#define FUNC_DESC_07 "Join one table from given range to the end of another table."
        -: 1092:#define FUNC_DESC_08 "Join one table from outside given range to the end of another table."
        -: 1093:#define FUNC_DESC_09 "Copy data from one array to another new array."
        -: 1094:#define FUNC_DESC_10 "Remove data from array that lie outside of given range."
        -: 1095:#define FUNC_DESC_11 "Remove data from array that lie inside of given range."
        -: 1096:#define FUNC_DESC_12 "Remove element from array placed in given index."
        -: 1097:#define FUNC_DESC_13 "Create local array with specified type."
        -: 1098:#define FUNC_DESC_14 "Insert single value of specified type into array at given index."
        -: 1099:#define FUNC_DESC_15 "Copy data of specified type from one array to another."
        -: 1100:
        -: 1101:/**
        -: 1102: * Lista funkcji testujących moduł.
        -: 1103: * Każda z osobna uruchamiana jest przez odpowiednią funkcję.
        -: 1104: * Dzięki zbiorowi funkcji zdefiniowanemu poniżej dzieje się to automatycznie.
        -: 1105: * Wszystkie funkcje są ze sobą powiązane.
        -: 1106: * 
        -: 1107: * ZMIANA KOLEJNOŚCI WYWOŁYWANIA FUNKCJI MOŻE ZMIENIĆ WYNIKI A NAWET WYWOŁAĆ
        -: 1108: * BŁĄD NARUSZENIA OCHRONY PAMIĘCI.
        -: 1109: */
        -: 1110:MST_FUNCTION MSV_ArraySuiteFunctions[] =
        -: 1111:{
        -: 1112:	{ MST_STRINGIFY(mst_array_create),             FUNC_DESC_01, NULL },
        -: 1113:	{ MST_STRINGIFY(mst_array_destroy),            FUNC_DESC_02, NULL },
        -: 1114:	{ MST_STRINGIFY(mst_array_realloc),            FUNC_DESC_03, NULL },
        -: 1115:	{ MST_STRINGIFY(mst_array_realloc_min),        FUNC_DESC_04, NULL },
        -: 1116:	{ MST_STRINGIFY(mst_array_insert_value),       FUNC_DESC_05, NULL },
        -: 1117:	{ MST_STRINGIFY(mst_array_insert_values),      FUNC_DESC_06, NULL },
        -: 1118:	{ MST_STRINGIFY(mst_array_join_slice),         FUNC_DESC_07, NULL },
        -: 1119:	{ MST_STRINGIFY(mst_array_join_slice_inverse), FUNC_DESC_08, NULL },
        -: 1120:	{ MST_STRINGIFY(mst_array_copy),               FUNC_DESC_09, NULL },
        -: 1121:	{ MST_STRINGIFY(mst_array_slice),              FUNC_DESC_10, NULL },
        -: 1122:	{ MST_STRINGIFY(mst_array_remove_range),       FUNC_DESC_11, NULL },
        -: 1123:	{ MST_STRINGIFY(mst_array_remove),             FUNC_DESC_12, NULL },
        -: 1124:	{ MST_STRINGIFY(mst_array_base_return),        FUNC_DESC_13, NULL },
        -: 1125:	{ MST_STRINGIFY(mst_array_base_insert),        FUNC_DESC_14, NULL },
        -: 1126:	{ MST_STRINGIFY(mst_array_base_copy_return),   FUNC_DESC_15, NULL },
        -: 1127:	{ MST_LASTRECORD }
        -: 1128:};
        -: 1129:
        -: 1130:/**
        -: 1131: * Zbiór funkcji testujących moduł.
        -: 1132: * Przekazywany do funkcji main, pozwala na uruchomienie wszystkich testów.
        -: 1133: */
        -: 1134:MST_SUITE MSV_ArraySuite =
        -: 1135:{
        -: 1136:	">>> ARRAY MODULE",
        -: 1137:	TRUE,
        -: 1138:	NULL,
        -: 1139:	mst_array_teardown,
        -: 1140:	NULL,
        -: 1141:	MSV_ArraySuiteFunctions
        -: 1142:};
        -: 1143:
        -: 1144:/* w przypadku wszystkich zestawów na raz nie dołączaj funkcji main */
        -: 1145:#ifndef MST_ALL_SUITES
        -: 1146:
        -: 1147:	/**
        -: 1148:	 * Funkcja główna dołączana tylko przy uruchomieniu tego testu.
        -: 1149:	 * W przypadku testowania wszystkich modułów na raz, nie jest uwzględniana w kompilacji.
        -: 1150:	 * 
        -: 1151:	 * @param argc Ilość parametrów przekazywanych do programu.
        -: 1152:	 * @param argv Parametry przekazane do programu z wiersza poleceń.
        -: 1153:	 * 
        -: 1154:	 * @return Kod błędu lub wartość 0.
        -: 1155:	 */
        1: 1156:	int main( int argc, char **argv )
        -: 1157:	{
        1: 1158:		MSTST_ARRAY_DATA data = { NULL, NULL };
        -: 1159:		
        -: 1160:		IGVAR argc;
        -: 1161:		IGVAR argv;
        -: 1162:
        -: 1163:		/* przypisz dane do zbioru */
        1: 1164:		MSV_ArraySuite.Data = &data;
        -: 1165:
        1: 1166:		return mst_run_suite( &MSV_ArraySuite );
        -: 1167:	}
        -: 1168:
        -: 1169:#endif
