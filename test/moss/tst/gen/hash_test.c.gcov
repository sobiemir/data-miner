        -:    0:Source:../hash_test.c
        -:    0:Programs:7
        -:    1:/*
        -:    2: *  Moss Library >>> http://moss.aculo.pl
        -:    3: *
        -:    4: *     /'\_/`\                           
        -:    5: *    /\      \    ___     ____    ____  
        -:    6: *    \ \ \__\ \  / __`\  /',__\  /',__\ 
        -:    7: *     \ \ \_/\ \/\ \L\ \/\__, `\/\__, `\
        -:    8: *      \ \_\\ \_\ \____/\/\____/\/\____/
        -:    9: *       \/_/ \/_/\/___/  \/___/  \/___/ 
        -:   10: *
        -:   11: *  Test file for "Hash" module.
        -:   12: *
        -:   13: *  This file is part of Moss Library
        -:   14: *  Copyright (c) by sobiemir <sobiemir@aculo.pl>
        -:   15: *
        -:   16: *  This program is free software: you can redistribute it and/or modify
        -:   17: *  it under the terms of the GNU General Public License as published by
        -:   18: *  the Free Software Foundation, either version 3 of the License, or
        -:   19: *  (at your option) any later version.
        -:   20: *
        -:   21: *  This program is distributed in the hope that it will be useful,
        -:   22: *  but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   23: *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   24: *  GNU General Public License for more details.
        -:   25: *
        -:   26: *  You should have received a copy of the GNU General Public License
        -:   27: *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   28: */
        -:   29:
        -:   30:#include <stdio.h>
        -:   31:#include <msconf.h>
        -:   32:#include <mstest.h>
        -:   33:#include <moss/hash.h>
        -:   34:
        -:   35:#ifdef MSD_COMPILER_MSC
        -:   36:	__pragma( warning(push) )
        -:   37:	__pragma( warning(disable:4127))    /* conditional expression is constant */
        -:   38:#endif
        -:   39:
        -:   40:/*
        -:   41:======================================================================================================================
        -:   42:------------------------------------------------------------------------------------------------------------------
        -:   43:	DJB ALGORITHMS
        -:   44:------------------------------------------------------------------------------------------------------------------
        -:   45:======================================================================================================================
        -:   46:*/
        -:   47:
        -:   48:/**
        -:   49: * Testuje funkcje skrótu oparte na algorytmie DJB2.
        -:   50: * Sprawdza warianty: standardowy, mbs, wcs.
        -:   51: */
        1:   52:int mst_hash_djb2( MST_FUNCTION *info )
        -:   53:{
        1:   54:	const char    atest[] =  "DJBKey";
        1:   55:	const wchar_t wtest[] = L"DJBKey";
        -:   56:	
        -:   57:	uint32_t result, wresult1, wresult2;
        -:   58:
        1:   59:	mst_prepare( info );
        -:   60:
        -:   61:	/* char */
        1:   62:	result = ms_hash_32_djb2( atest, strlen(atest) );
        1:   63:	mst_assert_uint( result, ==, 0xABDE625E );
        1:   64:	result = ms_hash_mbs_32_djb2( atest );
        1:   65:	mst_assert_uint( result, ==, 0xABDE625E );
        -:   66:
        -:   67:	/* wchar_t */
        1:   68:	wresult1 = ms_hash_32_djb2( wtest, wcslen(wtest) * sizeof(wchar_t) );
        1:   69:	wresult2 = ms_hash_wcs_32_djb2( wtest );
        -:   70:
        -:   71:	if( sizeof(wchar_t) == 2 )
        -:   72:	{
        -:   73:		mst_assert_uint( wresult1, ==, 0x1C78C0DE );
        -:   74:		mst_assert_uint( wresult2, ==, 0x1C78C0DE );
        -:   75:	}
        -:   76:	else if( sizeof(wchar_t) == 4 )
        -:   77:	{
        1:   78:		mst_assert_uint( wresult1, ==, 0x07DB25DE );
        1:   79:		mst_assert_uint( wresult2, ==, 0x07DB25DE );
        -:   80:	}
        -:   81:
        1:   82:	return MSEC_OK;
        -:   83:}
        -:   84:
        -:   85:/**
        -:   86: * Testuje funkcje skrótu oparte na algorytmie DJB2A.
        -:   87: * Sprawdza warianty: standardowy, mbs, wcs.
        -:   88: */
        1:   89:int mst_hash_djb2a( MST_FUNCTION *info )
        -:   90:{
        1:   91:	const char    atest[] =  "DJBKey";
        1:   92:	const wchar_t wtest[] = L"DJBKey";
        -:   93:	
        -:   94:	uint32_t result, wresult1, wresult2;
        -:   95:
        1:   96:	mst_prepare( info );
        -:   97:
        -:   98:	/* char */
        1:   99:	result = ms_hash_32_djb2a( atest, strlen(atest) );
        1:  100:	mst_assert_uint( result, ==, 0x99329EBE );
        1:  101:	result = ms_hash_mbs_32_djb2a( atest );
        1:  102:	mst_assert_uint( result, ==, 0x99329EBE );
        -:  103:
        -:  104:	/* wchar_t */
        1:  105:	wresult1 = ms_hash_32_djb2a( wtest, wcslen(wtest) * sizeof(wchar_t) );
        1:  106:	wresult2 = ms_hash_wcs_32_djb2a( wtest );
        -:  107:
        -:  108:	if( sizeof(wchar_t) == 2 )
        -:  109:	{
        -:  110:		mst_assert_uint( wresult1, ==, 0xB9704D7E );
        -:  111:		mst_assert_uint( wresult2, ==, 0xB9704D7E );
        -:  112:	}
        -:  113:	else if( sizeof(wchar_t) == 4 )
        -:  114:	{
        1:  115:		mst_assert_uint( wresult1, ==, 0x509BE3FE );
        1:  116:		mst_assert_uint( wresult2, ==, 0x509BE3FE );
        -:  117:	}
        -:  118:
        1:  119:	return MSEC_OK;
        -:  120:}
        -:  121:
        -:  122:/*
        -:  123:======================================================================================================================
        -:  124:------------------------------------------------------------------------------------------------------------------
        -:  125:	SDBM ALGORITHM
        -:  126:------------------------------------------------------------------------------------------------------------------
        -:  127:======================================================================================================================
        -:  128:*/
        -:  129:
        -:  130:/**
        -:  131: * Testuje funkcje skrótu oparte na algorytmie SDBM.
        -:  132: * Sprawdza warianty: standardowy, mbs, wcs.
        -:  133: */
        1:  134:int mst_hash_sdbm( MST_FUNCTION *info )
        -:  135:{
        1:  136:	const char    atest[] =  "SDBMKey";
        1:  137:	const wchar_t wtest[] = L"SDBMKey";
        -:  138:	
        -:  139:	uint32_t result, wresult1, wresult2;
        -:  140:
        1:  141:	mst_prepare( info );
        -:  142:
        -:  143:	/* char */
        1:  144:	result = ms_hash_32_sdbm( atest, strlen(atest) );
        1:  145:	mst_assert_uint( result, ==, 0xFA861463 );
        1:  146:	result = ms_hash_mbs_32_sdbm( atest );
        1:  147:	mst_assert_uint( result, ==, 0xFA861463 );
        -:  148:
        -:  149:	/* wchar_t */
        1:  150:	wresult1 = ms_hash_32_sdbm( wtest, wcslen(wtest) * sizeof(wchar_t) );
        1:  151:	wresult2 = ms_hash_wcs_32_sdbm( wtest );
        -:  152:
        -:  153:	if( sizeof(wchar_t) == 2 )
        -:  154:	{
        -:  155:		mst_assert_uint( wresult1, ==, 0x3A38E971 );
        -:  156:		mst_assert_uint( wresult2, ==, 0x3A38E971 );
        -:  157:	}
        -:  158:	else if( sizeof(wchar_t) == 4 )
        -:  159:	{
        1:  160:		mst_assert_uint( wresult1, ==, 0x53C918F1 );
        1:  161:		mst_assert_uint( wresult2, ==, 0x53C918F1 );
        -:  162:	}
        -:  163:
        1:  164:	return MSEC_OK;
        -:  165:}
        -:  166:
        -:  167:/*
        -:  168:======================================================================================================================
        -:  169:------------------------------------------------------------------------------------------------------------------
        -:  170:	JOAAT ALGORITHM
        -:  171:------------------------------------------------------------------------------------------------------------------
        -:  172:======================================================================================================================
        -:  173:*/
        -:  174:
        -:  175:/**
        -:  176: * Testuje funkcje skrótu oparte na algorytmie JOAAT.
        -:  177: * Sprawdza warianty: standardowy, mbs, wcs.
        -:  178: */
        1:  179:int mst_hash_joaat( MST_FUNCTION *info )
        -:  180:{
        1:  181:	const char    atest[] =  "JoaaTKey";
        1:  182:	const wchar_t wtest[] = L"JoaaTKey";
        -:  183:	
        -:  184:	uint32_t result, wresult1, wresult2;
        -:  185:
        1:  186:	mst_prepare( info );
        -:  187:
        -:  188:	/* char */
        1:  189:	result = ms_hash_32_joaat( atest, strlen(atest) );
        1:  190:	mst_assert_uint( result, ==, 0x94E6381F );
        1:  191:	result = ms_hash_mbs_32_joaat( atest );
        1:  192:	mst_assert_uint( result, ==, 0x94E6381F );
        -:  193:
        -:  194:	/* wchar_t */
        1:  195:	wresult1 = ms_hash_32_joaat( wtest, wcslen(wtest) * sizeof(wchar_t) );
        1:  196:	wresult2 = ms_hash_wcs_32_joaat( wtest );
        -:  197:
        -:  198:	if( sizeof(wchar_t) == 2 )
        -:  199:	{
        -:  200:		mst_assert_uint( wresult1, ==, 0xC24C203E );
        -:  201:		mst_assert_uint( wresult2, ==, 0xC24C203E );
        -:  202:	}
        -:  203:	else if( sizeof(wchar_t) == 4 )
        -:  204:	{
        1:  205:		mst_assert_uint( wresult1, ==, 0x311CEE84 );
        1:  206:		mst_assert_uint( wresult2, ==, 0x311CEE84 );
        -:  207:	}
        -:  208:
        1:  209:	return MSEC_OK;
        -:  210:}
        -:  211:
        -:  212:/*
        -:  213:======================================================================================================================
        -:  214:------------------------------------------------------------------------------------------------------------------
        -:  215:	FNV ALGORITHMS
        -:  216:------------------------------------------------------------------------------------------------------------------
        -:  217:======================================================================================================================
        -:  218:*/
        -:  219:
        -:  220:/**
        -:  221: * Testuje funkcje skrótu oparte na algorytmie FNV-1.
        -:  222: * Sprawdza warianty: standardowy, mbs, wcs.
        -:  223: */
        1:  224:int mst_hash_fnv1( MST_FUNCTION *info )
        -:  225:{
        1:  226:	const char    atest[] =  "FNVFamilyKey";
        1:  227:	const wchar_t wtest[] = L"FNVFamilyKey";
        -:  228:	
        -:  229:	uint32_t result32, w32result1, w32result2;
        -:  230:	uint64_t result64, w64result1, w64result2;
        -:  231:
        1:  232:	mst_prepare( info );
        -:  233:
        -:  234:	/* char, wersja 32 bitowa */
        1:  235:	result32 = ms_hash_32_fnv1( atest, strlen(atest) );
        1:  236:	mst_assert_uint( result32, ==, 0x7119B356 );
        1:  237:	result32 = ms_hash_mbs_32_fnv1( atest );
        1:  238:	mst_assert_uint( result32, ==, 0x7119B356 );
        -:  239:
        -:  240:	/* char, wersja 64 bitowa */
        1:  241:	result64 = ms_hash_64_fnv1( atest, strlen(atest) );
        1:  242:	mst_assert_uint( result64, ==, 0xC552531A28539836 );
        1:  243:	result64 = ms_hash_mbs_64_fnv1( atest );
        1:  244:	mst_assert_uint( result64, ==, 0xC552531A28539836 );
        -:  245:
        -:  246:	/* wchar_t, wersja 32 bitowa */
        1:  247:	w32result1 = ms_hash_32_fnv1( wtest, wcslen(wtest) * sizeof(wchar_t) );
        1:  248:	w32result2 = ms_hash_wcs_32_fnv1( wtest );
        -:  249:
        -:  250:	/* wchar_t, wersja 64 bitowa */
        1:  251:	w64result1 = ms_hash_64_fnv1( wtest, wcslen(wtest) * sizeof(wchar_t) );
        1:  252:	w64result2 = ms_hash_wcs_64_fnv1( wtest );
        -:  253:
        -:  254:	if( sizeof(wchar_t) == 2 )
        -:  255:	{
        -:  256:		mst_assert_uint( w32result1, ==, 0x7AFBDF48 );
        -:  257:		mst_assert_uint( w32result2, ==, 0x7AFBDF48 );
        -:  258:		mst_assert_uint( w64result1, ==, 0x3CB9F0BF944BFFC8 );
        -:  259:		mst_assert_uint( w64result2, ==, 0x3CB9F0BF944BFFC8 );
        -:  260:	}
        -:  261:	else if( sizeof(wchar_t) == 4 )
        -:  262:	{
        1:  263:		mst_assert_uint( w32result1, ==, 0x20ED7910 );
        1:  264:		mst_assert_uint( w32result2, ==, 0x20ED7910 );
        1:  265:		mst_assert_uint( w64result1, ==, 0x211BBD1C5D42E1D0 );
        1:  266:		mst_assert_uint( w64result2, ==, 0x211BBD1C5D42E1D0 );
        -:  267:	}
        -:  268:
        1:  269:	return MSEC_OK;
        -:  270:}
        -:  271:
        -:  272:/**
        -:  273: * Testuje funkcje skrótu oparte na algorytmie FNV-1A.
        -:  274: * Sprawdza warianty: standardowy, mbs, wcs.
        -:  275: */
        1:  276:int mst_hash_fnv1a( MST_FUNCTION *info )
        -:  277:{
        1:  278:	const char    atest[] =  "FNVFamilyKey";
        1:  279:	const wchar_t wtest[] = L"FNVFamilyKey";
        -:  280:	
        -:  281:	uint32_t result32, w32result1, w32result2;
        -:  282:	uint64_t result64, w64result1, w64result2;
        -:  283:
        1:  284:	mst_prepare( info );
        -:  285:
        -:  286:	/* char, wersja 32 bitowa */
        1:  287:	result32 = ms_hash_32_fnv1a( atest, strlen(atest) );
        1:  288:	mst_assert_uint( result32, ==, 0x94A2258C );
        1:  289:	result32 = ms_hash_mbs_32_fnv1a( atest );
        1:  290:	mst_assert_uint( result32, ==, 0x94A2258C );
        -:  291:
        -:  292:	/* char, wersja 64 bitowa */
        1:  293:	result64 = ms_hash_64_fnv1a( atest, strlen(atest) );
        1:  294:	mst_assert_uint( result64, ==, 0x27693918C0BB3CCC );
        1:  295:	result64 = ms_hash_mbs_64_fnv1a( atest );
        1:  296:	mst_assert_uint( result64, ==, 0x27693918C0BB3CCC );
        -:  297:
        -:  298:	/* wchar_t, wersja 32 bitowa */
        1:  299:	w32result1 = ms_hash_32_fnv1a( wtest, wcslen(wtest) * sizeof(wchar_t) );
        1:  300:	w32result2 = ms_hash_wcs_32_fnv1a( wtest );
        -:  301:
        -:  302:	/* wchar_t, wersja 32 bitowa */
        1:  303:	w64result1 = ms_hash_64_fnv1a( wtest, wcslen(wtest) * sizeof(wchar_t) );
        1:  304:	w64result2 = ms_hash_wcs_64_fnv1a( wtest );
        -:  305:
        -:  306:	if( sizeof(wchar_t) == 2 )
        -:  307:	{
        -:  308:		mst_assert_uint( w32result1, ==, 0xFA945892 );
        -:  309:		mst_assert_uint( w32result2, ==, 0xFA945892 );
        -:  310:		mst_assert_uint( w64result1, ==, 0xBC28813FCFD3D0F2 );
        -:  311:		mst_assert_uint( w64result2, ==, 0xBC28813FCFD3D0F2 );
        -:  312:	}
        -:  313:	else if( sizeof(wchar_t) == 4 )
        -:  314:	{
        1:  315:		mst_assert_uint( w32result1, ==, 0x9D543B0A );
        1:  316:		mst_assert_uint( w32result2, ==, 0x9D543B0A );
        1:  317:		mst_assert_uint( w64result1, ==, 0x87D2CE8C5EFA642A );
        1:  318:		mst_assert_uint( w64result2, ==, 0x87D2CE8C5EFA642A );
        -:  319:	}
        -:  320:
        1:  321:	return MSEC_OK;
        -:  322:}
        -:  323:
        -:  324:/*
        -:  325:======================================================================================================================
        -:  326:------------------------------------------------------------------------------------------------------------------
        -:  327:	MURMUR ALGORITHMS
        -:  328:------------------------------------------------------------------------------------------------------------------
        -:  329:======================================================================================================================
        -:  330:*/
        -:  331:
        -:  332:/**
        -:  333: * Testuje funkcje skrótu oparte na algorytmie Murmur.
        -:  334: * Sprawdza warianty: standardowy.
        -:  335: * Ze względu na algorytm nie zostały utworzone warianty mbs i wcs.
        -:  336: */
        1:  337:int mst_hash_murmur1( MST_FUNCTION *info )
        -:  338:{
        1:  339:	const char *atest[] =
        -:  340:	{
        -:  341:		"MurmurKey",
        -:  342:		"MurmurKey1",
        -:  343:		"MurmurKey12",
        -:  344:		"MurmurKey123"
        -:  345:	};
        -:  346:	uint32_t result;
        -:  347:
        1:  348:	mst_prepare( info );
        -:  349:
        1:  350:	result = ms_hash_32_murmur1( atest[0], strlen(atest[0]) );
        1:  351:	mst_assert_uint( result, ==, 0xAF772697 );
        1:  352:	result = ms_hash_32_murmur1( atest[1], strlen(atest[1]) );
        1:  353:	mst_assert_uint( result, ==, 0xEF00677C );
        1:  354:	result = ms_hash_32_murmur1( atest[2], strlen(atest[2]) );
        1:  355:	mst_assert_uint( result, ==, 0x66F61852 );
        1:  356:	result = ms_hash_32_murmur1( atest[3], strlen(atest[3]) );
        1:  357:	mst_assert_uint( result, ==, 0xC0AE799F );
        -:  358:
        1:  359:	return MSEC_OK;
        -:  360:}
        -:  361:
        -:  362:/**
        -:  363: * Testuje funkcje skrótu oparte na algorytmie Murmur2.
        -:  364: * Sprawdza warianty: standardowy.
        -:  365: * Ze względu na algorytm nie zostały utworzone warianty mbs i wcs.
        -:  366: */
        1:  367:int mst_hash_murmur2( MST_FUNCTION *info )
        -:  368:{
        1:  369:	const char *atest[] =
        -:  370:	{
        -:  371:		"MurmurKey",
        -:  372:		"MurmurKey1",
        -:  373:		"MurmurKey12",
        -:  374:		"MurmurKey123",
        -:  375:		"MurmurKey1234",
        -:  376:		"MurmurKey12345",
        -:  377:		"MurmurKey123456",
        -:  378:		"MurmurKey1234567"
        -:  379:	};
        -:  380:	uint32_t result32;
        -:  381:	uint64_t result64;
        -:  382:
        1:  383:	mst_prepare( info );
        -:  384:
        -:  385:	/* char, wersja 32 bitowa */
        1:  386:	result32 = ms_hash_32_murmur2( atest[0], strlen(atest[0]) );
        1:  387:	mst_assert_uint( result32, ==, 0xA6A87356 );
        1:  388:	result32 = ms_hash_32_murmur2( atest[1], strlen(atest[1]) );
        1:  389:	mst_assert_uint( result32, ==, 0xFE6E2293 );
        1:  390:	result32 = ms_hash_32_murmur2( atest[2], strlen(atest[2]) );
        1:  391:	mst_assert_uint( result32, ==, 0x5FF5020B );
        1:  392:	result32 = ms_hash_32_murmur2( atest[3], strlen(atest[3]) );
        1:  393:	mst_assert_uint( result32, ==, 0xF1D9CC0B );
        -:  394:
        -:  395:	/* char, wersja 64 bitowa */
        1:  396:	result64 = ms_hash_64_murmur2( atest[0], strlen(atest[0]) );
        1:  397:	mst_assert_uint( result64, ==, 0xE725056E186EB4D6 );
        1:  398:	result64 = ms_hash_64_murmur2( atest[1], strlen(atest[1]) );
        1:  399:	mst_assert_uint( result64, ==, 0x033CB80EC8BEB4BE );
        1:  400:	result64 = ms_hash_64_murmur2( atest[2], strlen(atest[2]) );
        1:  401:	mst_assert_uint( result64, ==, 0x2EB3FB4D381F500E );
        1:  402:	result64 = ms_hash_64_murmur2( atest[3], strlen(atest[3]) );
        1:  403:	mst_assert_uint( result64, ==, 0xF68B2345BE9FAD33 );
        1:  404:	result64 = ms_hash_64_murmur2( atest[4], strlen(atest[4]) );
        1:  405:	mst_assert_uint( result64, ==, 0x18A99EA9BFB13235 );
        1:  406:	result64 = ms_hash_64_murmur2( atest[5], strlen(atest[5]) );
        1:  407:	mst_assert_uint( result64, ==, 0x03E0C9B2EBC1F413 );
        1:  408:	result64 = ms_hash_64_murmur2( atest[6], strlen(atest[6]) );
        1:  409:	mst_assert_uint( result64, ==, 0x2F972DF4971465F0 );
        1:  410:	result64 = ms_hash_64_murmur2( atest[7], strlen(atest[7]) );
        1:  411:	mst_assert_uint( result64, ==, 0xD10ECF806D50F7D9 );
        -:  412:
        1:  413:	return MSEC_OK;
        -:  414:}
        -:  415:
        -:  416:/**
        -:  417: * Testuje funkcje skrótu oparte na algorytmie Murmur3.
        -:  418: * Sprawdza warianty: standardowy, mbs, wcs.
        -:  419: */
        1:  420:int mst_hash_murmur3( MST_FUNCTION *info )
        -:  421:{
        1:  422:	const char *atest[] =
        -:  423:	{
        -:  424:		"MurmurKey",
        -:  425:		"MurmurKey1",
        -:  426:		"MurmurKey12",
        -:  427:		"MurmurKey123"
        -:  428:	};
        1:  429:	const wchar_t *wtest[] =
        -:  430:	{
        -:  431:		L"MurmurKey",
        -:  432:		L"MurmurKey1",
        -:  433:		L"MurmurKey12",
        -:  434:		L"MurmurKey123"
        -:  435:	};
        -:  436:	uint32_t result;
        -:  437:	uint32_t wresult1[4];
        -:  438:	uint32_t wresult2[4];
        -:  439:
        1:  440:	mst_prepare( info );
        -:  441:
        -:  442:	/* char */
        1:  443:	result = ms_hash_32_murmur3( atest[0], strlen(atest[0]) );
        1:  444:	mst_assert_uint( result, ==, 0xF3D48C5C );
        1:  445:	result = ms_hash_mbs_32_murmur3( atest[0] );
        1:  446:	mst_assert_uint( result, ==, 0xF3D48C5C );
        1:  447:	result = ms_hash_32_murmur3( atest[1], strlen(atest[1]) );
        1:  448:	mst_assert_uint( result, ==, 0xAEE175B3 );
        1:  449:	result = ms_hash_mbs_32_murmur3( atest[1] );
        1:  450:	mst_assert_uint( result, ==, 0xAEE175B3 );
        1:  451:	result = ms_hash_32_murmur3( atest[2], strlen(atest[2]) );
        1:  452:	mst_assert_uint( result, ==, 0x859648EE );
        1:  453:	result = ms_hash_mbs_32_murmur3( atest[2] );
        1:  454:	mst_assert_uint( result, ==, 0x859648EE );
        1:  455:	result = ms_hash_32_murmur3( atest[3], strlen(atest[3]) );
        1:  456:	mst_assert_uint( result, ==, 0xE2050FD7 );
        1:  457:	result = ms_hash_mbs_32_murmur3( atest[3] );
        1:  458:	mst_assert_uint( result, ==, 0xE2050FD7 );
        -:  459:
        -:  460:	/* wchar_t */
        1:  461:	wresult1[0] = ms_hash_32_murmur3( wtest[0], wcslen(wtest[0]) * sizeof(wchar_t) );
        1:  462:	wresult2[0] = ms_hash_wcs_32_murmur3( wtest[0] );
        1:  463:	wresult1[1] = ms_hash_32_murmur3( wtest[1], wcslen(wtest[1]) * sizeof(wchar_t) );
        1:  464:	wresult2[1] = ms_hash_wcs_32_murmur3( wtest[1] );
        1:  465:	wresult1[2] = ms_hash_32_murmur3( wtest[2], wcslen(wtest[2]) * sizeof(wchar_t) );
        1:  466:	wresult2[2] = ms_hash_wcs_32_murmur3( wtest[2] );
        1:  467:	wresult1[3] = ms_hash_32_murmur3( wtest[3], wcslen(wtest[3]) * sizeof(wchar_t) );
        1:  468:	wresult2[3] = ms_hash_wcs_32_murmur3( wtest[3] );
        -:  469:
        -:  470:	if( sizeof(wchar_t) == 2 )
        -:  471:	{
        -:  472:		mst_assert_uint( wresult1[0], ==, 0xF3F54C78 );
        -:  473:		mst_assert_uint( wresult2[0], ==, 0xF3F54C78 );
        -:  474:		mst_assert_uint( wresult1[1], ==, 0x90A3A98D );
        -:  475:		mst_assert_uint( wresult2[1], ==, 0x90A3A98D );
        -:  476:		mst_assert_uint( wresult1[2], ==, 0x3849F3E5 );
        -:  477:		mst_assert_uint( wresult2[2], ==, 0x3849F3E5 );
        -:  478:		mst_assert_uint( wresult1[3], ==, 0x8AD19CEE );
        -:  479:		mst_assert_uint( wresult2[3], ==, 0x8AD19CEE );
        -:  480:	}
        -:  481:	else if( sizeof(wchar_t) == 4 )
        -:  482:	{
        1:  483:		mst_assert_uint( wresult1[0], ==, 0x26384360 );
        1:  484:		mst_assert_uint( wresult2[0], ==, 0x26384360 );
        1:  485:		mst_assert_uint( wresult1[1], ==, 0x6E196D7C );
        1:  486:		mst_assert_uint( wresult2[1], ==, 0x6E196D7C );
        1:  487:		mst_assert_uint( wresult1[2], ==, 0x955C377D );
        1:  488:		mst_assert_uint( wresult2[2], ==, 0x955C377D );
        1:  489:		mst_assert_uint( wresult1[3], ==, 0x47EC00B5 );
        1:  490:		mst_assert_uint( wresult2[3], ==, 0x47EC00B5 );
        -:  491:	}
        -:  492:
        1:  493:	return MSEC_OK;
        -:  494:}
        -:  495:
        -:  496:/*
        -:  497:======================================================================================================================
        -:  498:------------------------------------------------------------------------------------------------------------------
        -:  499:	XXHASH ALGORITHM
        -:  500:------------------------------------------------------------------------------------------------------------------
        -:  501:======================================================================================================================
        -:  502:*/
        -:  503:
        -:  504:/**
        -:  505: * Testuje funkcje skrótu oparte na algorytmie xxHash w wersji 32 bitowej.
        -:  506: * Sprawdza warianty: standardowy, mbs, wcs.
        -:  507: * Wersje zostały oddzielone z racji skomplikowania algorytmu.
        -:  508: */
        1:  509:int mst_hash_xxhash32( MST_FUNCTION *info )
        -:  510:{
        1:  511:	const char *atest[] =
        -:  512:	{
        -:  513:		"xxHashKey",
        -:  514:		"xxHashKey1",
        -:  515:		"xxHashKey12",
        -:  516:		"xxHashKey123",
        -:  517:		"xxHashKey1234",
        -:  518:		"xxHashKey12345",
        -:  519:		"xxHashKey123456",
        -:  520:		"xxHashKey1234567",
        -:  521:		"xxHashKey12345678",
        -:  522:		"xxHashKey123456789",
        -:  523:		"xxHashKey1234567890",
        -:  524:		"xxHashKey1234567890A",
        -:  525:		"xxHashKey1234567890AB",
        -:  526:		"xxHashKey1234567890ABC",
        -:  527:		"xxHashKey1234567890ABCD",
        -:  528:		"xxHashKey1234567890ABCDE"
        -:  529:	};
        1:  530:	const wchar_t *wtest[] =
        -:  531:	{
        -:  532:		L"xxHashKey",
        -:  533:		L"xxHashKey1",
        -:  534:		L"xxHashKey12",
        -:  535:		L"xxHashKey123",
        -:  536:		L"xxHashKey1234",
        -:  537:		L"xxHashKey12345",
        -:  538:		L"xxHashKey123456",
        -:  539:		L"xxHashKey1234567",
        -:  540:		L"xxHashKey12345678",
        -:  541:		L"xxHashKey123456789",
        -:  542:		L"xxHashKey1234567890",
        -:  543:		L"xxHashKey1234567890A",
        -:  544:		L"xxHashKey1234567890AB",
        -:  545:		L"xxHashKey1234567890ABC",
        -:  546:		L"xxHashKey1234567890ABCD",
        -:  547:		L"xxHashKey1234567890ABCDE",
        -:  548:		L"xHa"
        -:  549:	};
        -:  550:	size_t iter;
        -:  551:
        -:  552:	/* bok + góra = indeks który nie przeszedł lub testowany indeks */
        1:  553:	uint32_t svals[] =
        -:  554:	{
        -:  555:		/*   0           1           2           3    */
        -:  556:		0xAA245726, 0x4CE783F9, 0x3F5CBD0B, 0x6010A46F, /* 1  */
        -:  557:		0xC14A8983, 0xA94A4D5D, 0x1332968C, 0x078D4FA9, /* 5  */
        -:  558:		0x555CC6A2, 0xF634297E, 0x9502E6D8, 0xCBAB52F8, /* 9  */
        -:  559:		0x6386F7BD, 0xBCBBC336, 0x94138B2E, 0x12D0EF9C  /* 13 */
        -:  560:	};
        -:  561:
        1:  562:	mst_prepare( info );
        -:  563:
        -:  564:	/* char */
       17:  565:	for( iter = 0; iter < 16; ++iter )
        -:  566:	{
        -:  567:		/* printf( "PASS: %zu\n", iter ); */
       16:  568:		mst_assert_uint( ms_hash_32_xxhash(atest[iter], strlen(atest[iter])), ==, svals[iter] );
       16:  569:		mst_assert_uint( ms_hash_mbs_32_xxhash(atest[iter]), ==, svals[iter] );
        -:  570:	}
        -:  571:
        -:  572:	/* wchar_t */
        -:  573:	if( sizeof(wchar_t) == 2 )
        -:  574:	{
        -:  575:		/* bok + góra = indeks który nie przeszedł lub testowany indeks */
        -:  576:		uint32_t wvals[] =
        -:  577:		{
        -:  578:			/*   0           1           2           3    */
        -:  579:			0xB1727C1C, 0xE7BFFC27, 0x12EC6C22, 0x3E3E6AB6, /* 1  */
        -:  580:			0x1715C13C, 0xF739C79A, 0xA99CCC93, 0x6D9C4A7B, /* 5  */
        -:  581:			0xD6862D63, 0xDDDDE141, 0x83E080EC, 0x8C33E16E, /* 9  */
        -:  582:			0xDF5028E9, 0xEA6D9F73, 0xDCB2601E, 0xBFF627A8  /* 13 */
        -:  583:		};
        -:  584:
        -:  585:		for( iter = 0; iter < 16; ++iter )
        -:  586:		{
        -:  587:			/* printf( "PASS: %zu\n", iter ); */
        -:  588:			mst_assert_uint( ms_hash_32_xxhash(wtest[iter], wcslen(wtest[iter]) * sizeof(wchar_t)), ==, wvals[iter] );
        -:  589:			mst_assert_uint( ms_hash_wcs_32_xxhash(wtest[iter]), ==, wvals[iter] );
        -:  590:		}
        -:  591:		mst_assert_uint( ms_hash_32_xxhash(wtest[16], wcslen(wtest[16]) * sizeof(wchar_t)), ==, 0xE7A5359C );
        -:  592:		mst_assert_uint( ms_hash_wcs_32_xxhash(wtest[16]), ==, 0xE7A5359C );
        -:  593:	}
        -:  594:	else if( sizeof(wchar_t) == 4 )
        -:  595:	{
        -:  596:		/* bok + góra = indeks który nie przeszedł lub testowany indeks */
        1:  597:		uint32_t wvals[] =
        -:  598:		{
        -:  599:			/*   0           1           2           3    */
        -:  600:			0x81821019, 0x9C36E8D1, 0x4D41319E, 0x46627E6C, /* 1  */
        -:  601:			0xC834F32C, 0x19546302, 0x5AA824CB, 0xE364E8DA, /* 5  */
        -:  602:			0xC4ABFD9E, 0x997130A2, 0x746D3676, 0xF8B9B25F, /* 9  */
        -:  603:			0x796C2C10, 0x4B00CABD, 0x7AF740F1, 0x082AC455  /* 13 */
        -:  604:		};
        -:  605:
       17:  606:		for( iter = 0; iter < 16; ++iter )
        -:  607:		{
        -:  608:			/* printf( "PASS: %zu\n", iter ); */
       16:  609:			mst_assert_uint( ms_hash_32_xxhash(wtest[iter], wcslen(wtest[iter]) * sizeof(wchar_t)), ==, wvals[iter] );
       16:  610:			mst_assert_uint( ms_hash_wcs_32_xxhash(wtest[iter]), ==, wvals[iter] );
        -:  611:		}
        1:  612:		mst_assert_uint( ms_hash_32_xxhash(wtest[16], wcslen(wtest[16]) * sizeof(wchar_t)), ==, 0xE684C0C9 );
        1:  613:		mst_assert_uint( ms_hash_wcs_32_xxhash(wtest[16]), ==, 0xE684C0C9 );
        -:  614:	}
        -:  615:
        1:  616:	return MSEC_OK;
        -:  617:}
        -:  618:
        -:  619:/**
        -:  620: * 11.
        -:  621: * Testuje funkcje skrótu oparte na algorytmie xxHash w wersji 64 bitowej.
        -:  622: * Sprawdza warianty: standardowy, mbs, wcs.
        -:  623: * Wersje zostały oddzielone z racji skomplikowania algorytmu.
        -:  624: */
        1:  625:int mst_hash_xxhash64( MST_FUNCTION *info )
        -:  626:{
        1:  627:	const char *atest[] =
        -:  628:	{
        -:  629:		"xxHashKey",
        -:  630:		"xxHashKey1",
        -:  631:		"xxHashKey12",
        -:  632:		"xxHashKey123",
        -:  633:		"xxHashKey1234",
        -:  634:		"xxHashKey12345",
        -:  635:		"xxHashKey123456",
        -:  636:		"xxHashKey1234567",
        -:  637:		"xxHashKey12345678",
        -:  638:		"xxHashKey123456789",
        -:  639:		"xxHashKey1234567890",
        -:  640:		"xxHashKey1234567890A",
        -:  641:		"xxHashKey1234567890AB",
        -:  642:		"xxHashKey1234567890ABC",
        -:  643:		"xxHashKey1234567890ABCD",
        -:  644:		"xxHashKey1234567890ABCDE",
        -:  645:		"xxHashKey1234567890ABCDEF",
        -:  646:		"xxHashKey1234567890ABCDEFG",
        -:  647:		"xxHashKey1234567890ABCDEFGH",
        -:  648:		"xxHashKey1234567890ABCDEFGHI",
        -:  649:		"xxHashKey1234567890ABCDEFGHIJ",
        -:  650:		"xxHashKey1234567890ABCDEFGHIJK",
        -:  651:		"xxHashKey1234567890ABCDEFGHIJKL",
        -:  652:		"xxHashKey1234567890ABCDEFGHIJKLM",
        -:  653:		"xxHashKey1234567890ABCDEFGHIJKLMN",
        -:  654:		"xxHashKey1234567890ABCDEFGHIJKLMNO",
        -:  655:		"xxHashKey1234567890ABCDEFGHIJKLMNOP",
        -:  656:		"xxHashKey1234567890ABCDEFGHIJKLMNOPQ",
        -:  657:		"xxHashKey1234567890ABCDEFGHIJKLMNOPQR",
        -:  658:		"xxHashKey1234567890ABCDEFGHIJKLMNOPQRS",
        -:  659:		"xxHashKey1234567890ABCDEFGHIJKLMNOPQRST",
        -:  660:		"xxHashKey1234567890ABCDEFGHIJKLMNOPQRSTU"
        -:  661:	};
        1:  662:	const wchar_t *wtest[] =
        -:  663:	{
        -:  664:		L"xxHashKey",
        -:  665:		L"xxHashKey1",
        -:  666:		L"xxHashKey12",
        -:  667:		L"xxHashKey123",
        -:  668:		L"xxHashKey1234",
        -:  669:		L"xxHashKey12345",
        -:  670:		L"xxHashKey123456",
        -:  671:		L"xxHashKey1234567",
        -:  672:		L"xxHashKey12345678",
        -:  673:		L"xxHashKey123456789",
        -:  674:		L"xxHashKey1234567890",
        -:  675:		L"xxHashKey1234567890A",
        -:  676:		L"xxHashKey1234567890AB",
        -:  677:		L"xxHashKey1234567890ABC",
        -:  678:		L"xxHashKey1234567890ABCD",
        -:  679:		L"xxHashKey1234567890ABCDE",
        -:  680:		L"xxHashKey1234567890ABCDEF",
        -:  681:		L"xxHashKey1234567890ABCDEFG",
        -:  682:		L"xxHashKey1234567890ABCDEFGH",
        -:  683:		L"xxHashKey1234567890ABCDEFGHI",
        -:  684:		L"xxHashKey1234567890ABCDEFGHIJ",
        -:  685:		L"xxHashKey1234567890ABCDEFGHIJK",
        -:  686:		L"xxHashKey1234567890ABCDEFGHIJKL",
        -:  687:		L"xxHashKey1234567890ABCDEFGHIJKLM",
        -:  688:		L"xxHashKey1234567890ABCDEFGHIJKLMN",
        -:  689:		L"xxHashKey1234567890ABCDEFGHIJKLMNO",
        -:  690:		L"xxHashKey1234567890ABCDEFGHIJKLMNOP",
        -:  691:		L"xxHashKey1234567890ABCDEFGHIJKLMNOPQ",
        -:  692:		L"xxHashKey1234567890ABCDEFGHIJKLMNOPQR",
        -:  693:		L"xxHashKey1234567890ABCDEFGHIJKLMNOPQRS",
        -:  694:		L"xxHashKey1234567890ABCDEFGHIJKLMNOPQRST",
        -:  695:		L"xxHashKey1234567890ABCDEFGHIJKLMNOPQRSTU",
        -:  696:		L"xHa"
        -:  697:	};
        -:  698:	size_t iter;
        -:  699:
        -:  700:	/* bok + góra = indeks który nie przeszedł lub testowany indeks */
        1:  701:	uint64_t svals[] =
        -:  702:	{
        -:  703:		/*       0                   1                  2                   3         */
        -:  704:		0xCCB13b34381D3BC3, 0xFE9E608A92DC0052, 0x476293E945CD01CA, 0x60994333F604772E, /* 1  */
        -:  705:		0x106965EA9CCB1B71, 0x1DF205AB5B08F190, 0xCE09BB4F9AE1E735, 0x6DAE389F1CCE5FC1, /* 5  */
        -:  706:		0x5DC89520B44FAD5C, 0x4C10EC5D3E35D873, 0x4B32DA7972CFB23E, 0xBFE7A8BD4CF506EC, /* 9  */
        -:  707:		0x93A43287A250FD1B, 0x9A2E1C94C2CF75AB, 0x0033A2EC1091D7C6, 0x7701DB6969D456C9, /* 13 */
        -:  708:		0xB41C144388E63E75, 0x2422B5712245042D, 0x99843CAA64085549, 0xC22FD2E6E5702AA8, /* 17 */
        -:  709:		0x9F63287B9AB53247, 0x14DD70B25E8360D9, 0x2C58D4C555A1AC53, 0x54005F16E0852B1C, /* 21 */
        -:  710:		0x9D2B1ED629E1148C, 0x3BAFD1F48F1451A6, 0x88BDE5165D8F91C3, 0xB3141CEEB2B51949, /* 25 */
        -:  711:		0x137B4F591C02F472, 0xE7A8784CF718FAFA, 0x30D71242A787EF27, 0x9A3CD311BF4F0150  /* 29 */
        -:  712:	};
        -:  713:
        1:  714:	mst_prepare( info );
        -:  715:
        -:  716:	/* char */
       33:  717:	for( iter = 0; iter < 32; ++iter )
        -:  718:	{
        -:  719:		/* printf( "PASS: %zu\n", iter ); */
       32:  720:		mst_assert_uint( ms_hash_64_xxhash(atest[iter], strlen(atest[iter])), ==, svals[iter] );
       32:  721:		mst_assert_uint( ms_hash_mbs_64_xxhash(atest[iter]), ==, svals[iter] );
        -:  722:	}
        -:  723:
        -:  724:	/* wchar_t */
        -:  725:	if( sizeof(wchar_t) == 2 )
        -:  726:	{
        -:  727:		/* bok + góra = indeks który nie przeszedł lub testowany indeks */
        -:  728:		uint64_t wvals[] =
        -:  729:		{
        -:  730:			/*       0                   1                  2                   3         */
        -:  731:			0xC4B3F6FA7DC28773, 0x7A512B6C3210BE77, 0x2FAC324BEA747D96, 0xEED2C0A835410B66, /* 1  */
        -:  732:			0x00953C5A4095F61D, 0x81D3478290B1F178, 0xD35FC1F6B85D13D8, 0x977D4B0FDFA8F1C1, /* 5  */
        -:  733:			0x7ADF94D2914CD233, 0x16C809B48FB63AB8, 0xFFE4BABA597677B6, 0xD160F19584FCAB13, /* 9  */
        -:  734:			0xA1C4C718619FA515, 0x483B2F9572EE18A3, 0x77205C92EB87C6AE, 0x9F164DE6454C2164, /* 13 */
        -:  735:			0xA3E0BFA318EF4DE9, 0x26DA2CF97AAFBC99, 0x167BF77AFDBB7EBB, 0xA8CEDEC59916E568, /* 17 */
        -:  736:			0xDFE3383DE455529E, 0x4EDC0ED2EF444C66, 0x0FCC0AD42C9F62A9, 0x7237B9FE45D6B848, /* 21 */
        -:  737:			0x27895691C9934944, 0x203324A6A23BB2BC, 0x400ADB9EC70177D6, 0x226130124B5A2E5F, /* 25 */
        -:  738:			0x3ABCD6C65D38E409, 0xDA9E8FBE6A3D8EF6, 0x6BAF6788CE53AC4E, 0x5777F60E5EE4569F  /* 29 */
        -:  739:		};
        -:  740:
        -:  741:		for( iter = 0; iter < 32; ++iter )
        -:  742:		{
        -:  743:			/* printf( "PASS: %zu\n", iter ); */
        -:  744:			mst_assert_uint( ms_hash_64_xxhash(wtest[iter], wcslen(wtest[iter]) * sizeof(wchar_t)), ==, wvals[iter] );
        -:  745:			mst_assert_uint( ms_hash_wcs_64_xxhash(wtest[iter]), ==, wvals[iter] );
        -:  746:		}
        -:  747:		mst_assert_uint( ms_hash_64_xxhash(wtest[32], wcslen(wtest[32]) * sizeof(wchar_t)), ==, 0xED8644FBB587A3EA );
        -:  748:		mst_assert_uint( ms_hash_wcs_64_xxhash(wtest[32]), ==, 0xED8644FBB587A3EA );
        -:  749:	}
        -:  750:	else if( sizeof(wchar_t) == 4 )
        -:  751:	{
        -:  752:		/* bok + góra = indeks który nie przeszedł lub testowany indeks */
        1:  753:		uint64_t wvals[] =
        -:  754:		{
        -:  755:			/*       0                   1                  2                   3         */
        -:  756:			0x581B838C77AA7766, 0xBC7408062FDE6DD2, 0x5A430BBBA0FE5E1D, 0xCC68DEC5E8493245, /* 1  */
        -:  757:			0x3112B0383799B462, 0x43A1494570BA6E6A, 0x1A3C2306B7544963, 0x551183299A21D197, /* 5  */
        -:  758:			0x8A44A284CCAB492B, 0x5D8FEBD75CC5B1EE, 0x00AD05F19494FD1D, 0x1AA33245B637EDEF, /* 9  */
        -:  759:			0x6AB973CBE34DA193, 0x8ED16F3C726A46A1, 0x4FA8D00C5F8C15BD, 0x3366E4B02009E7AD, /* 13 */
        -:  760:			0xB654A90B1699B57E, 0x54D4B03F42E78826, 0xD51DA92BA8C5F6B6, 0x8B3F0FE2070231B2, /* 17 */
        -:  761:			0xE128E8BD97040514, 0x415E1A493DF6A862, 0x5F79B71714A1132D, 0x3307507BCFD7F94C, /* 21 */
        -:  762:			0x9D22FDD1676497F4, 0xD7169F26648AC51C, 0x6E8F919E18CD3525, 0xE61637E48BCFBAE2, /* 25 */
        -:  763:			0x9A63E2EDDB54DFC2, 0x47FCBD5D8CA7708D, 0x3E8D8893B37D977C, 0x7251EF739972D15A  /* 29 */
        -:  764:		};
        -:  765:
       33:  766:		for( iter = 0; iter < 32; ++iter )
        -:  767:		{
        -:  768:			/* printf( "PASS: %zu\n", iter ); */
       32:  769:			mst_assert_uint( ms_hash_64_xxhash(wtest[iter], wcslen(wtest[iter]) * sizeof(wchar_t)), ==, wvals[iter] );
       32:  770:			mst_assert_uint( ms_hash_wcs_64_xxhash(wtest[iter]), ==, wvals[iter] );
        -:  771:		}
        1:  772:		mst_assert_uint( ms_hash_64_xxhash(wtest[32], wcslen(wtest[32]) * sizeof(wchar_t)), ==, 0x562A87F545E2D7A5 );
        1:  773:		mst_assert_uint( ms_hash_wcs_64_xxhash(wtest[32]), ==, 0x562A87F545E2D7A5 );
        -:  774:	}
        -:  775:
        1:  776:	return MSEC_OK;
        -:  777:}
        -:  778:
        -:  779:/*
        -:  780:======================================================================================================================
        -:  781:------------------------------------------------------------------------------------------------------------------
        -:  782:	URUCHAMIANIE TESTÓW
        -:  783:------------------------------------------------------------------------------------------------------------------
        -:  784:======================================================================================================================
        -:  785:*/
        -:  786:
        -:  787:/**
        -:  788: * Opisy funkcji testujących.
        -:  789: * Wyświetlane są zaraz pod nazwą funkcji podczas testowania.
        -:  790: * Uporzadkowane w kolejności rozmieszczenia funkcji w liście.
        -:  791: */
        -:  792:#define FUNC_DESC_01 "Test value returned by all djb2 functions."
        -:  793:#define FUNC_DESC_02 "Test value returned by all djb2a functions."
        -:  794:#define FUNC_DESC_03 "Test value returned by all sdbm functions."
        -:  795:#define FUNC_DESC_04 "Test value returned by all joaat functions."
        -:  796:#define FUNC_DESC_05 "Test value returned by all 32 and 64 bit fnv1 functions."
        -:  797:#define FUNC_DESC_06 "Test value returned by all 32 and 64 bit fnv1a functions."
        -:  798:#define FUNC_DESC_07 "Test value returned by murmur1 function."
        -:  799:#define FUNC_DESC_08 "Test value returned by 32 and 64 bit murmur2 functions."
        -:  800:#define FUNC_DESC_09 "Test value returned by murmur3 functions."
        -:  801:#define FUNC_DESC_10 "Test value returned by 32 bit xxhash functions."
        -:  802:#define FUNC_DESC_11 "Test value returned by 64 bit xxhash functions."
        -:  803:
        -:  804:/**
        -:  805: * Lista funkcji testujących moduł.
        -:  806: * Każda z osobna uruchamiana jest przez odpowiednią funkcję.
        -:  807: * Dzięki zbiorowi funkcji zdefiniowanemu poniżej dzieje się to automatycznie.
        -:  808: * Funkcje nie są ze sobą powiązane, więc mogą być wykonywane w dowolnej kolejności.
        -:  809: */
        -:  810:MST_FUNCTION MSV_HashSuiteFunctions[] =
        -:  811:{
        -:  812:	{ MST_STRINGIFY(mst_hash_djb2),     FUNC_DESC_01, NULL },
        -:  813:	{ MST_STRINGIFY(mst_hash_djb2a),    FUNC_DESC_02, NULL },
        -:  814:	{ MST_STRINGIFY(mst_hash_sdbm),     FUNC_DESC_03, NULL },
        -:  815:	{ MST_STRINGIFY(mst_hash_joaat),    FUNC_DESC_04, NULL },
        -:  816:	{ MST_STRINGIFY(mst_hash_fnv1),     FUNC_DESC_05, NULL },
        -:  817:	{ MST_STRINGIFY(mst_hash_fnv1a),    FUNC_DESC_06, NULL },
        -:  818:	{ MST_STRINGIFY(mst_hash_murmur1),  FUNC_DESC_07, NULL },
        -:  819:	{ MST_STRINGIFY(mst_hash_murmur2),  FUNC_DESC_08, NULL },
        -:  820:	{ MST_STRINGIFY(mst_hash_murmur3),  FUNC_DESC_09, NULL },
        -:  821:	{ MST_STRINGIFY(mst_hash_xxhash32), FUNC_DESC_10, NULL },
        -:  822:	{ MST_STRINGIFY(mst_hash_xxhash64), FUNC_DESC_11, NULL },
        -:  823:	{ MST_LASTRECORD }
        -:  824:};
        -:  825:
        -:  826:/**
        -:  827: * Zbiór funkcji testujących moduł.
        -:  828: * Przekazywany do funkcji main, pozwala na uruchomienie wszystkich testów.
        -:  829: */
        -:  830:MST_SUITE MSV_HashSuite =
        -:  831:{
        -:  832:	">>> HASH MODULE",
        -:  833:	TRUE,
        -:  834:	NULL,
        -:  835:	NULL,
        -:  836:	NULL,
        -:  837:	MSV_HashSuiteFunctions
        -:  838:};
        -:  839:
        -:  840:/* w przypadku wszystkich zestawów na raz nie dołączaj funkcji main */
        -:  841:#ifndef MST_ALL_SUITES
        -:  842:
        -:  843:	/**
        -:  844:	 * Funkcja główna dołączana tylko przy uruchomieniu tego testu.
        -:  845:	 * W przypadku testowania wszystkich modułów na raz, nie jest uwzględniana w kompilacji.
        -:  846:	 * 
        -:  847:	 * @param argc Ilość parametrów przekazywanych do programu.
        -:  848:	 * @param argv Parametry przekazane do programu z wiersza poleceń.
        -:  849:	 * 
        -:  850:	 * @return Kod błędu lub wartość 0.
        -:  851:	 */
        1:  852:	int main( int argc, char **argv )
        -:  853:	{
        -:  854:		IGVAR argc;
        -:  855:		IGVAR argv;
        -:  856:
        1:  857:		mst_run_suite( &MSV_HashSuite );
        -:  858:
        1:  859:		return 0;
        -:  860:	}
        -:  861:
        -:  862:#endif
        -:  863:#ifdef MSD_COMPILER_MSC
        -:  864:	__pragma( warning(pop) )
        -:  865:#endif
        -:  866:
