        -:    0:Source:../../src/hash/murmur.c
        -:    0:Programs:7
        -:    1:/*
        -:    2: *  Moss Library >>> http://moss.aculo.pl
        -:    3: *
        -:    4: *     /'\_/`\                           
        -:    5: *    /\      \    ___     ____    ____  
        -:    6: *    \ \ \__\ \  / __`\  /',__\  /',__\ 
        -:    7: *     \ \ \_/\ \/\ \L\ \/\__, `\/\__, `\
        -:    8: *      \ \_\\ \_\ \____/\/\____/\/\____/
        -:    9: *       \/_/ \/_/\/___/  \/___/  \/___/ 
        -:   10: *
        -:   11: *  Source file for "Hash" module, Murmur algorithms [Public Domain].
        -:   12: *  All modifications are based on GPLv3 license.
        -:   13: *  
        -:   14: *  This file is part of Moss Library
        -:   15: *  Copyright (c) by sobiemir <sobiemir@aculo.pl>
        -:   16: *
        -:   17: *  This program is free software: you can redistribute it and/or modify
        -:   18: *  it under the terms of the GNU General Public License as published by
        -:   19: *  the Free Software Foundation, either version 3 of the License, or
        -:   20: *  (at your option) any later version.
        -:   21: *
        -:   22: *  This program is distributed in the hope that it will be useful,
        -:   23: *  but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   24: *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   25: *  GNU General Public License for more details.
        -:   26: *
        -:   27: *  You should have received a copy of the GNU General Public License
        -:   28: *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   29: */
        -:   30:
        -:   31:#include <moss/hash.h>
        -:   32:
        -:   33:#define MSN_H32M3_1 0xCC9E2D51
        -:   34:#define MSN_H32M3_2 0x1B873593
        -:   35:#define MSN_H32M3_3 0xE6546B64
        -:   36:#define MSN_H32M2   0x5BD1E995
        -:   37:#define MSN_H64M2   0xC6A4A7935BD1E995ull
        -:   38:#define MSN_H32M1   0xC6A4A793
        -:   39:
        -:   40:#ifdef MSD_COMPILER_MSC
        -:   41:	__pragma( warning(push) )
        -:   42:	__pragma( warning(disable:4127))    /* conditional expression is constant */
        -:   43:#endif
        -:   44:
        -:   45:/**
        -:   46: * Miesza 32 bitowy skrót danych z podaną wartością.
        -:   47: * 
        -:   48: * @param  hash  Aktualny skrót danych.
        -:   49: * @param  value Wartość do mieszania.
        -:   50: * @return       Nowy skrót danych.
        -:   51: */
        -:   52:INLINE static uint32_t msf_hash_mix32_value( uint32_t hash, uint32_t value );
        -:   53:
        -:   54:/* ================================================================================================================== */
        -:   55:
        8:   56:uint32_t ms_hash_32_murmur3( const void *data, size_t length )
        -:   57:{
        8:   58:	uint32_t hash = MSD_HASH_SEED;
        8:   59:	uint32_t ch4b = 0;
        -:   60:	size_t   iter;
        -:   61:
        8:   62:	const uint32_t *cdat = data;
        -:   63:	const uint8_t  *adat;
        -:   64:
        8:   65:	assert( data );
        -:   66:
        -:   67:	/* murmur3 pobiera 4 bajtowe porcje */
       67:   68:	for( iter = length >> 2; iter--; )
       51:   69:		hash = msf_hash_mix32_value( hash, *cdat++ );
        -:   70:
        -:   71:	/* dolicz odpadki */
        8:   72:	adat = (const uint8_t*)cdat;
        8:   73:	switch( length & 3 )
        -:   74:	{
        1:   75:		case 3: ch4b |= adat[2] << 16;
        2:   76:		case 2: ch4b |= adat[1] << 8;
        3:   77:		case 1: ch4b |= adat[0];
        3:   78:		        ch4b *= MSN_H32M3_1;
        3:   79:		        ch4b  = MSX_ROTL32(ch4b, 15);
        3:   80:		        ch4b *= MSN_H32M3_2;
        3:   81:		        hash ^= ch4b;
        -:   82:	}
        -:   83:
        8:   84:	hash ^= length;
        8:   85:	hash ^= hash >> 16;
        8:   86:	hash *= 0x85EBCA6B;
        8:   87:	hash ^= hash >> 13;
        8:   88:	hash *= 0xC2B2AE35;
        8:   89:	hash ^= hash >> 16;
        -:   90:
        8:   91:	return hash;
        -:   92:}
        -:   93:
        -:   94:/* ================================================================================================================== */
        -:   95:
        4:   96:uint32_t ms_hash_32_murmur2( const void *data, size_t length )
        -:   97:{
        -:   98:	/* ta linijka uniemożliwia stworzenie rozwiązania dedykowanego dla mbs i wcs */
        4:   99:	uint32_t hash = MSD_HASH_SEED ^ length;
        -:  100:	uint32_t ch4b;
        -:  101:
        4:  102:	const uint32_t *cdat = data;
        -:  103:	const uint8_t  *adat;
        -:  104:
        4:  105:	assert( data );
        -:  106:
       13:  107:	for( ; length > 3; length -= 4 )
        9:  108:		ch4b  = *cdat++,
        9:  109:		ch4b *= MSN_H32M2,
        9:  110:		ch4b ^= ch4b >> 24,
        9:  111:		ch4b *= MSN_H32M2,
        9:  112:		hash *= MSN_H32M2,
        9:  113:		hash ^= ch4b;
        -:  114:	
        -:  115:	/* murmur2 również posiada odpadki */
        4:  116:	adat = (const uint8_t*)cdat;
        4:  117:	switch( length )
        -:  118:	{
        1:  119:		case 3: hash ^= adat[2] << 16;
        2:  120:		case 2: hash ^= adat[1] << 8;
        3:  121:		case 1: hash ^= adat[0];
        3:  122:		        hash *= MSN_H32M2;
        -:  123:	}
        -:  124:
        4:  125:	hash ^= hash >> 13;
        4:  126:	hash *= MSN_H32M2;
        4:  127:	hash ^= hash >> 15;
        -:  128:	
        4:  129:	return hash;
        -:  130:}
        -:  131:
        -:  132:/* ================================================================================================================== */
        -:  133:
        4:  134:uint32_t ms_hash_32_murmur1( const void *data, size_t length )
        -:  135:{
        -:  136:	/* ta linijka uniemożliwia stworzenie rozwiązania dedykowanego dla mbs i wcs */
        4:  137:	uint32_t hash = MSD_HASH_SEED ^ (length * MSN_H32M1);
        -:  138:	
        4:  139:	const uint32_t *cdat = data;
        -:  140:	const uint8_t  *adat;
        -:  141:
        4:  142:	assert( data );
        -:  143:
       13:  144:	for( ; length > 3; length -= 4 )
        9:  145:		(hash += *cdat++), (hash *= MSN_H32M1), (hash ^= hash >> 16);
        -:  146:
        -:  147:	/* dolicz odpadki */
        4:  148:	adat = (const uint8_t*)cdat;
        4:  149:	switch( length )
        -:  150:	{
        1:  151:		case 3: hash += adat[2] << 16;
        2:  152:		case 2: hash += adat[1] << 8;
        3:  153:		case 1: hash += adat[0];
        3:  154:		        hash *= MSN_H32M1;
        3:  155:		        hash ^= hash >> 16;
        -:  156:	}
        -:  157:	
        4:  158:	hash *= MSN_H32M1;
        4:  159:	hash ^= hash >> 10;
        4:  160:	hash *= MSN_H32M1;
        4:  161:	hash ^= hash >> 17;
        -:  162:
        4:  163:	return hash;
        -:  164:}
        -:  165:
        -:  166:/* ================================================================================================================== */
        -:  167:
        8:  168:uint64_t ms_hash_64_murmur2( const void *data, size_t length )
        -:  169:{
        -:  170:	/* ta linijka uniemożliwia stworzenie rozwiązania dedykowanego dla mbs i wcs */
        8:  171:	uint64_t hash = MSD_HASH_SEED ^ (length * MSN_H64M2);
        -:  172:	uint64_t ch4b;
        -:  173:	
        8:  174:	const uint64_t *cdat = data;
        -:  175:	const uint8_t  *adat;
        -:  176:
        8:  177:	assert( data );
        -:  178:
       17:  179:	for( ; length > 7; length -= 8 )
        9:  180:		ch4b  = *cdat++,
        9:  181:		ch4b *= MSN_H64M2,
        9:  182:		ch4b ^= ch4b >> 47,
        9:  183:		ch4b *= MSN_H64M2,
        9:  184:		hash ^= ch4b,
        9:  185:		hash *= MSN_H64M2;
        -:  186:
        -:  187:	/* dolicz odpadki, jest ich 8 w 64 bitowej porcji */
        8:  188:	adat = (const uint8_t*)cdat;
        8:  189:	switch( length )
        -:  190:	{
        1:  191:		case 7: hash ^= (uint64_t)adat[6] << 48;
        2:  192:		case 6: hash ^= (uint64_t)adat[5] << 40;
        3:  193:		case 5: hash ^= (uint64_t)adat[4] << 32;
        4:  194:		case 4: hash ^= (uint64_t)adat[3] << 24;
        5:  195:		case 3: hash ^= (uint64_t)adat[2] << 16;
        6:  196:		case 2: hash ^= (uint64_t)adat[1] << 8;
        7:  197:		case 1: hash ^= (uint64_t)adat[0];
        7:  198:		        hash *= MSN_H64M2;
        -:  199:	}
        -:  200:	
        8:  201:	hash ^= hash >> 47;
        8:  202:	hash *= MSN_H64M2;
        8:  203:	hash ^= hash >> 47;
        -:  204:
        8:  205:	return hash;
        -:  206:}
        -:  207:
        -:  208:#ifdef MSD_HASH_MBS_FUNCTIONS
        -:  209:
        -:  210:/* ================================================================================================================== */
        -:  211:
        4:  212:uint32_t ms_hash_mbs_32_murmur3( const char *data )
        -:  213:{
        4:  214:	uint32_t hash = MSD_HASH_SEED;
        4:  215:	size_t   slen = 0;
        -:  216:	uint32_t ch4b;
        -:  217:	size_t   nbit;
        -:  218:
        4:  219:	const uint32_t *cdat = (const uint32_t*)data;
        -:  220:
        4:  221:	assert( data );
        -:  222:
        -:  223:	/* mieszaj i licz długość ciągu znaków */
       17:  224:	while( ch4b = *cdat++, (nbit = MSX_FIND8B0IN32B(ch4b)) == 0 )
        9:  225:		hash  = msf_hash_mix32_value( hash, ch4b ),
        9:  226:		slen += 4;
        -:  227:
        -:  228:	/* dolicz odpadki */
        4:  229:	if( nbit > 1 )
        3:  230:		ch4b &= 0xFFFFFFFF >> ((5 - nbit) << 3),
        3:  231:		ch4b *= MSN_H32M3_1,
        3:  232:		ch4b  = MSX_ROTL32( ch4b, 15 ),
        3:  233:		ch4b *= MSN_H32M3_2,
        3:  234:		hash ^= ch4b,
        3:  235:		slen += nbit - 1;
        -:  236:
        4:  237:	hash ^= slen;
        4:  238:	hash ^= hash >> 16;
        4:  239:	hash *= 0x85EBCA6B;
        4:  240:	hash ^= hash >> 13;
        4:  241:	hash *= 0xC2B2AE35;
        4:  242:	hash ^= hash >> 16;
        -:  243:
        4:  244:	return hash;
        -:  245:}
        -:  246:
        -:  247:#endif
        -:  248:#ifdef MSD_HASH_WCS_FUNCTIONS
        -:  249:
        -:  250:/* ================================================================================================================== */
        -:  251:
        4:  252:uint32_t ms_hash_wcs_32_murmur3( const wchar_t *data )
        -:  253:{
        4:  254:	uint32_t hash = MSD_HASH_SEED,
        -:  255:			 ch4b;
        4:  256:	size_t   slen = 0;
        -:  257:
        4:  258:	const uint32_t *cdat = (const uint32_t*)data;
        -:  259:
        4:  260:	assert( data );
        -:  261:
        -:  262:	/* 2 bajtowy wchar_t */
        -:  263:	if( sizeof(wchar_t) == 2 )
        -:  264:		while( (ch4b = *cdat++) != 0 )
        -:  265:		{
        -:  266:			/* sprawdź czy pierwszy znak w porcji będzie równy 0 */
        -:  267:			if( !(ch4b & 0x0000FFFF) )
        -:  268:				break;
        -:  269:			/* jeżeli drugi znak jest równy 0, to ten pierwszy nadal pozostaje do obliczenia */
        -:  270:			if( !(ch4b & 0xFFFF0000) )
        -:  271:			{
        -:  272:				ch4b *= MSN_H32M3_1;
        -:  273:				ch4b  = MSX_ROTL32( ch4b, 15 );
        -:  274:				ch4b *= MSN_H32M3_2;
        -:  275:				hash ^= ch4b;
        -:  276:				slen += 2;
        -:  277:				break;
        -:  278:			}
        -:  279:			/* w przeciwnym wypadku licz całość */
        -:  280:			hash  = msf_hash_mix32_value( hash, ch4b );
        -:  281:			slen += 4;
        -:  282:		}
        -:  283:	/* 4 bajtowy wchar_t - brak odpadków... */
        -:  284:	else if( sizeof(wchar_t) == 4 )
       50:  285:		while( (ch4b = *cdat++) != 0 )
       42:  286:			hash  = msf_hash_mix32_value( hash, ch4b ),
       42:  287:			slen += 4;
        -:  288:
        4:  289:	hash ^= slen;
        4:  290:	hash ^= hash >> 16;
        4:  291:	hash *= 0x85EBCA6B;
        4:  292:	hash ^= hash >> 13;
        4:  293:	hash *= 0xC2B2AE35;
        4:  294:	hash ^= hash >> 16;
        -:  295:
        4:  296:	return hash;
        -:  297:}
        -:  298:
        -:  299:#endif
        -:  300:
        -:  301:/* ================================================================================================================== */
        -:  302:
      102:  303:INLINE static uint32_t msf_hash_mix32_value( uint32_t hash, uint32_t value )
        -:  304:{
      102:  305:	value *= MSN_H32M3_1;
      102:  306:	value  = MSX_ROTL32( value, 15 );
      102:  307:	value *= MSN_H32M3_2;
      102:  308:	hash  ^= value;
      102:  309:	hash   = MSX_ROTL32( hash, 13 );
        -:  310:
      102:  311:	return hash + ((hash << 2) + MSN_H32M3_3);
        -:  312:}
        -:  313:
        -:  314:#ifdef MSD_COMPILER_MSC
        -:  315:	__pragma( warning(pop) )
        -:  316:#endif
