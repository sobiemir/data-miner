        -:    0:Source:../../src/hash/xxhash.c
        -:    0:Programs:7
        -:    1:/*
        -:    2: *  Moss Library >>> http://moss.aculo.pl
        -:    3: *
        -:    4: *     /'\_/`\                           
        -:    5: *    /\      \    ___     ____    ____  
        -:    6: *    \ \ \__\ \  / __`\  /',__\  /',__\ 
        -:    7: *     \ \ \_/\ \/\ \L\ \/\__, `\/\__, `\
        -:    8: *      \ \_\\ \_\ \____/\/\____/\/\____/
        -:    9: *       \/_/ \/_/\/___/  \/___/  \/___/ 
        -:   10: *
        -:   11: *  Source file for "Hash" module, xxHash algorithm [BSD 2-Clause License].
        -:   12: *  All modifications are based on GPLv3 license.
        -:   13: *  
        -:   14: *  This file is part of Moss Library
        -:   15: *  Copyright (c) by sobiemir <sobiemir@aculo.pl>
        -:   16: *
        -:   17: *  This program is free software: you can redistribute it and/or modify
        -:   18: *  it under the terms of the GNU General Public License as published by
        -:   19: *  the Free Software Foundation, either version 3 of the License, or
        -:   20: *  (at your option) any later version.
        -:   21: *
        -:   22: *  This program is distributed in the hope that it will be useful,
        -:   23: *  but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   24: *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   25: *  GNU General Public License for more details.
        -:   26: *
        -:   27: *  You should have received a copy of the GNU General Public License
        -:   28: *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   29: */
        -:   30:
        -:   31:/*
        -:   32: *  Functions based on xxHash implementation on BSD license.
        -:   33: *  Original license:
        -:   34: *
        -:   35: *  xxHash - Fast Hash algorithm
        -:   36: *  Copyright (C) 2012-2016, Yann Collet
        -:   37: *
        -:   38: *  BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
        -:   39: *
        -:   40: *  Redistribution and use in source and binary forms, with or without
        -:   41: *  modification, are permitted provided that the following conditions are
        -:   42: *  met:
        -:   43: *
        -:   44: *  * Redistributions of source code must retain the above copyright
        -:   45: *    notice, this list of conditions and the following disclaimer.
        -:   46: *
        -:   47: *  * Redistributions in binary form must reproduce the above
        -:   48: *    copyright notice, this list of conditions and the following disclaimer
        -:   49: *    in the documentation and/or other materials provided with the
        -:   50: *    distribution.
        -:   51: *
        -:   52: *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        -:   53: *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        -:   54: *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
        -:   55: *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
        -:   56: *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        -:   57: *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
        -:   58: *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        -:   59: *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
        -:   60: *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   61: *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
        -:   62: *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   63: *
        -:   64: *  You can contact the author at :
        -:   65: *  - xxHash homepage: http://www.xxhash.com
        -:   66: *  - xxHash source repository : https://github.com/Cyan4973/xxHash
        -:   67: */
        -:   68:
        -:   69:#include <moss/hash.h>
        -:   70:
        -:   71:/* wartości dla 32 bitowych funkcji */
        -:   72:#define MSN_H32XX_1 2654435761u
        -:   73:#define MSN_H32XX_2 2246822519u
        -:   74:#define MSN_H32XX_3 3266489917u
        -:   75:#define MSN_H32XX_4 668265263u
        -:   76:#define MSN_H32XX_5 374761393u
        -:   77:
        -:   78:/* wartości dla 64 bitowych funkcji */
        -:   79:#define MSN_H64XX_1 11400714785074694791ull
        -:   80:#define MSN_H64XX_2 14029467366897019727ull
        -:   81:#define MSN_H64XX_3 1609587929392839161ull
        -:   82:#define MSN_H64XX_4 9650029242287828579ull
        -:   83:#define MSN_H64XX_5 2870177450012600261ull
        -:   84:
        -:   85:#ifdef MSD_COMPILER_MSC
        -:   86:	__pragma( warning(push) )
        -:   87:	__pragma( warning(disable:4307))    /* integral constant overflow */
        -:   88:	__pragma( warning(disable:4127))    /* conditional expression is constant */
        -:   89:#endif
        -:   90:
        -:   91:/**
        -:   92: * Miesza 64 bitowy skrót danych z podaną wartością.
        -:   93: * 
        -:   94: * @param  hash  Aktualny skrót danych.
        -:   95: * @param  value Wartość do mieszania.
        -:   96: * @return       Nowy skrót danych.
        -:   97: */
        -:   98:INLINE static uint64_t msf_hash_mix64_value( uint64_t hash, uint64_t value );
        -:   99:
        -:  100:/**
        -:  101: * Miesza 64 bitowy skrót danych z kolejną wartością pobraną z danych.
        -:  102: * 
        -:  103: * @param  hash  Aktualny skrót danych.
        -:  104: * @param  value Wartość do mieszania.
        -:  105: * @return       Nowy skrót danych.
        -:  106: */
        -:  107:INLINE static uint64_t msf_hash_mix64_char64( uint64_t hash, uint64_t c64 );
        -:  108:
        -:  109:/**
        -:  110: * Szuka 8 bitowego zera w 4 porcjach 32 bitowych wartości.
        -:  111: * W przypadku gdy zero zostanie znalezione, funkcja zwróci jego indeks rozpoczynający się od wartości 1.
        -:  112: * 
        -:  113: * @param  data Dane do przeszukania.
        -:  114: * @return      Indeks rozpoczynający się od 1 lub wartość 0.
        -:  115: */
        -:  116:INLINE static size_t msf_hash_mbs_32s8b0_check( const uint32_t *data );
        -:  117:
        -:  118:/**
        -:  119: * Szuka 8 bitowego zera w 4 porcjach 64 bitowych wartości.
        -:  120: * W przypadku gdy zero zostanie znalezione, funkcja zwróci jego indeks rozpoczynający się od wartości 1.
        -:  121: * 
        -:  122: * @param  data Dane do przeszukania.
        -:  123: * @return      Indeks rozpoczynający się od 1 lub wartość 0.
        -:  124: */
        -:  125:INLINE static size_t msf_hash_mbs_64s8b0_check( const uint64_t *data );
        -:  126:
        -:  127:/**
        -:  128: * Szuka 16 bitowego zera w 4 porcjach 32 bitowych wartości.
        -:  129: * W przypadku gdy zero zostanie znalezione, funkcja zwróci jego indeks rozpoczynający się od wartości 1.
        -:  130: * 
        -:  131: * @param  data Dane do przeszukania.
        -:  132: * @return      Indeks rozpoczynający się od 1 lub wartość 0.
        -:  133: */
        -:  134:INLINE static size_t msf_hash_mbs_32s16b0_check( const uint32_t *data );
        -:  135:
        -:  136:/**
        -:  137: * Szuka 16 bitowego zera w 4 porcjach 64 bitowych wartości.
        -:  138: * W przypadku gdy zero zostanie znalezione, funkcja zwróci jego indeks rozpoczynający się od wartości 1.
        -:  139: * 
        -:  140: * @param  data Dane do przeszukania.
        -:  141: * @return      Indeks rozpoczynający się od 1 lub wartość 0.
        -:  142: */
        -:  143:INLINE static size_t msf_hash_mbs_64s16b0_check( const uint64_t *data );
        -:  144:
        -:  145:/**
        -:  146: * Szuka 32 bitowego zera w 4 porcjach 32 bitowych wartości.
        -:  147: * W przypadku gdy zero zostanie znalezione, funkcja zwróci jego indeks rozpoczynający się od wartości 1.
        -:  148: * 
        -:  149: * @param  data Dane do przeszukania.
        -:  150: * @return      Indeks rozpoczynający się od 1 lub wartość 0.
        -:  151: */
        -:  152:INLINE static size_t msf_hash_mbs_32s32b0_check( const uint32_t *data );
        -:  153:
        -:  154:/**
        -:  155: * Szuka 32 bitowego zera w 4 porcjach 64 bitowych wartości.
        -:  156: * W przypadku gdy zero zostanie znalezione, funkcja zwróci jego indeks rozpoczynający się od wartości 1.
        -:  157: * 
        -:  158: * @param  data Dane do przeszukania.
        -:  159: * @return      Indeks rozpoczynający się od 1 lub wartość 0.
        -:  160: */
        -:  161:INLINE static size_t msf_hash_mbs_64s32b0_check( const uint64_t *data );
        -:  162:
        -:  163:/* ================================================================================================================== */
        -:  164:
       33:  165:uint32_t ms_hash_32_xxhash( const void *data, size_t length )
        -:  166:{
       33:  167:	uint32_t hash = 0;
        -:  168:
       33:  169:	const uint32_t *cdat = data;
        -:  170:	const uint8_t  *adat;
        -:  171:
       33:  172:	assert( data );
        -:  173:
       33:  174:	if( length > 0xF )
        -:  175:	{
       25:  176:		uint32_t val1 = MSD_HASH_SEED + MSN_H32XX_1 + MSN_H32XX_2;
       25:  177:		uint32_t val2 = MSD_HASH_SEED + MSN_H32XX_2;
       25:  178:		uint32_t val3 = MSD_HASH_SEED;
       25:  179:		uint32_t val4 = MSD_HASH_SEED - MSN_H32XX_1;
        -:  180:
        -:  181:		/* dziel na 16, pobierane będą 4 porcje po 32 bity, 32 bity => 4 bajty, 4 * 4 = 16 */
       25:  182:		size_t iter = length >> 4;
        -:  183:
        -:  184:		do
       69:  185:			(val1 += *cdat++ * MSN_H32XX_2), (val1 = MSX_ROTL32(val1, 13)), (val1 *= MSN_H32XX_1),
       69:  186:			(val2 += *cdat++ * MSN_H32XX_2), (val2 = MSX_ROTL32(val2, 13)), (val2 *= MSN_H32XX_1),
       69:  187:			(val3 += *cdat++ * MSN_H32XX_2), (val3 = MSX_ROTL32(val3, 13)), (val3 *= MSN_H32XX_1),
       69:  188:			(val4 += *cdat++ * MSN_H32XX_2), (val4 = MSX_ROTL32(val4, 13)), (val4 *= MSN_H32XX_1);
       69:  189:		while( --iter );
        -:  190:
       75:  191:		hash = MSX_ROTL32( val1, 1  ) + MSX_ROTL32( val2, 7  ) +
       50:  192:		       MSX_ROTL32( val3, 12 ) + MSX_ROTL32( val4, 18 );
        -:  193:	}
        -:  194:	else
        8:  195:		hash = MSD_HASH_SEED + MSN_H32XX_5;
        -:  196:
        -:  197:	/* dodaj długość do skrótu i nałóż maskę aby wykryć odpadki */
       33:  198:	hash   += length;
       33:  199:	length &= 0xF;
        -:  200:
        -:  201:	/* przejmuj odpadki */
       33:  202:	if( length > 11 )
        9:  203:		(hash += *cdat++ * MSN_H32XX_3), (hash = MSX_ROTL32(hash, 17) * MSN_H32XX_4),
        9:  204:		(hash += *cdat++ * MSN_H32XX_3), (hash = MSX_ROTL32(hash, 17) * MSN_H32XX_4),
        9:  205:		(hash += *cdat++ * MSN_H32XX_3), (hash = MSX_ROTL32(hash, 17) * MSN_H32XX_4), (length -= 12);
       24:  206:	else if( length > 7 )
        8:  207:		(hash += *cdat++ * MSN_H32XX_3), (hash = MSX_ROTL32(hash, 17) * MSN_H32XX_4),
        8:  208:		(hash += *cdat++ * MSN_H32XX_3), (hash = MSX_ROTL32(hash, 17) * MSN_H32XX_4), (length -= 8);
       16:  209:	else if( length > 3 )
        8:  210:		(hash += *cdat++ * MSN_H32XX_3), (hash = MSX_ROTL32(hash, 17) * MSN_H32XX_4), (length -= 4);
        -:  211:
        -:  212:	/* odpadki mniejsze niż 4 bajty */
       33:  213:	adat = (const uint8_t*)cdat;
       33:  214:	switch( length )
        -:  215:	{
        4:  216:		case 3: (hash += *adat++ * MSN_H32XX_5), (hash = MSX_ROTL32(hash, 11) * MSN_H32XX_1);
        8:  217:		case 2: (hash += *adat++ * MSN_H32XX_5), (hash = MSX_ROTL32(hash, 11) * MSN_H32XX_1);
       12:  218:		case 1: (hash += *adat++ * MSN_H32XX_5), (hash = MSX_ROTL32(hash, 11) * MSN_H32XX_1);
        -:  219:	}
        -:  220:
       33:  221:	hash ^= hash >> 15;
       33:  222:	hash *= MSN_H32XX_2;
       33:  223:	hash ^= hash >> 13;
       33:  224:	hash *= MSN_H32XX_3;
       33:  225:	hash ^= hash >> 16;
        -:  226:
       33:  227:	return hash;
        -:  228:}
        -:  229:
        -:  230:/* ================================================================================================================== */
        -:  231:
       65:  232:uint64_t ms_hash_64_xxhash( const void *data, size_t length )
        -:  233:{
       65:  234:	uint64_t hash = 0;
        -:  235:
       65:  236:	const uint64_t *cdat = data;
        -:  237:	const uint32_t *vdat;
        -:  238:	const uint8_t  *adat;
        -:  239:
       65:  240:	assert( data );
        -:  241:
       65:  242:	if( length > 0x1F )
        -:  243:	{
       41:  244:		uint64_t val1 = MSD_HASH_SEED + MSN_H64XX_1 + MSN_H64XX_2;
       41:  245:		uint64_t val2 = MSD_HASH_SEED + MSN_H64XX_2;
       41:  246:		uint64_t val3 = MSD_HASH_SEED;
       41:  247:		uint64_t val4 = MSD_HASH_SEED - MSN_H64XX_1;
        -:  248:
        -:  249:		/* dziel na 32, będą pobierane 4 porcje po 64 bity, 64 bity => 8 bajtów, 4 * 8 = 32 */
       41:  250:		size_t iter = length >> 5;
        -:  251:
        -:  252:		do
       93:  253:			(val1 += *cdat++ * MSN_H64XX_2), (val1 = MSX_ROTL64(val1, 31)), (val1 *= MSN_H64XX_1),
       93:  254:			(val2 += *cdat++ * MSN_H64XX_2), (val2 = MSX_ROTL64(val2, 31)), (val2 *= MSN_H64XX_1),
       93:  255:			(val3 += *cdat++ * MSN_H64XX_2), (val3 = MSX_ROTL64(val3, 31)), (val3 *= MSN_H64XX_1),
       93:  256:			(val4 += *cdat++ * MSN_H64XX_2), (val4 = MSX_ROTL64(val4, 31)), (val4 *= MSN_H64XX_1);
       93:  257:		while( --iter );
        -:  258:
      123:  259:		hash = MSX_ROTL64( val1, 1  ) + MSX_ROTL64( val2, 7  ) +
       82:  260:		       MSX_ROTL64( val3, 12 ) + MSX_ROTL64( val4, 18 );
        -:  261:
       41:  262:		hash = msf_hash_mix64_value( hash, val1 );
       41:  263:		hash = msf_hash_mix64_value( hash, val2 );
       41:  264:		hash = msf_hash_mix64_value( hash, val3 );
       41:  265:		hash = msf_hash_mix64_value( hash, val4 );
        -:  266:	}
        -:  267:	else
       24:  268:		hash = MSD_HASH_SEED + MSN_H64XX_5;
        -:  269:	
        -:  270:	/* dodaj długość do skrótu i nałóż maskę aby wykryć odpadki */
       65:  271:	hash   += length;
       65:  272:	length &= 0x1F;
        -:  273:
        -:  274:	/* przejmuj odpadki */
       65:  275:	if( length > 23 )
       16:  276:		hash = msf_hash_mix64_char64( hash, *cdat++ ),
       16:  277:		hash = msf_hash_mix64_char64( hash, *cdat++ ),
       16:  278:		hash = msf_hash_mix64_char64( hash, *cdat++ ), length -= 24;
       49:  279:	else if( length > 15 )
       16:  280:		hash = msf_hash_mix64_char64( hash, *cdat++ ),
       16:  281:		hash = msf_hash_mix64_char64( hash, *cdat++ ), length -= 16;
       33:  282:	else if( length > 7 )
       17:  283:		hash = msf_hash_mix64_char64( hash, *cdat++ ), length -= 8;
        -:  284:
        -:  285:	/* odpadki mniejsze niż 8 bajtów */
       65:  286:	vdat = (const uint32_t*)cdat;
       65:  287:	if( length > 3 )
       33:  288:		(hash ^= *vdat++ * MSN_H64XX_1), (hash = MSX_ROTL64(hash, 23) * MSN_H64XX_2 + MSN_H64XX_3), (length -= 4);
        -:  289:
        -:  290:	/* odpadki mniejsze niż 4 bajty */
       65:  291:	adat = (const uint8_t*)vdat;
       65:  292:	switch( length )
        -:  293:	{
        8:  294:		case 3: (hash ^= *adat++ * MSN_H64XX_5), (hash = MSX_ROTL64(hash, 11) * MSN_H64XX_1);
       16:  295:		case 2: (hash ^= *adat++ * MSN_H64XX_5), (hash = MSX_ROTL64(hash, 11) * MSN_H64XX_1);
       24:  296:		case 1: (hash ^= *adat++ * MSN_H64XX_5), (hash = MSX_ROTL64(hash, 11) * MSN_H64XX_1);
        -:  297:	}
        -:  298:
       65:  299:	hash ^= hash >> 33;
       65:  300:	hash *= MSN_H64XX_2;
       65:  301:	hash ^= hash >> 29;
       65:  302:	hash *= MSN_H64XX_3;
       65:  303:	hash ^= hash >> 32;
        -:  304:
       65:  305:	return hash;
        -:  306:}
        -:  307:
        -:  308:#ifdef MSD_HASH_MBS_FUNCTIONS
        -:  309:
        -:  310:/* ================================================================================================================== */
        -:  311:
       16:  312:uint32_t ms_hash_mbs_32_xxhash( const char *data )
        -:  313:{
       16:  314:	uint32_t hash = 0;
       16:  315:	size_t   slen = 0;
        -:  316:	size_t   nbit;
        -:  317:
       16:  318:	const uint32_t *cdat = (const uint32_t*)data;
        -:  319:	const uint8_t  *adat;
        -:  320:
        -:  321:	/* wartości przy optymalizacji i tak już powinny być znane... */
       16:  322:	uint32_t val1 = MSD_HASH_SEED + MSN_H32XX_1 + MSN_H32XX_2;
       16:  323:	uint32_t val2 = MSD_HASH_SEED + MSN_H32XX_2;
       16:  324:	uint32_t val3 = MSD_HASH_SEED;
       16:  325:	uint32_t val4 = MSD_HASH_SEED - MSN_H32XX_1;
        -:  326:
       16:  327:	assert( data );
        -:  328:
        -:  329:	/* szukaj zera jeszcze przed rozpoczęciem pętli */
       16:  330:	nbit = msf_hash_mbs_32s8b0_check( cdat );
       16:  331:	if( !nbit )
        -:  332:	{
        -:  333:		/* przetwarzaj, dopóki kod poniżej nie znajdzie 0 w ciągu */
       27:  334:		while( !nbit )
        -:  335:			/* po każdej pętli dodawaj ilość sprawdzonych bajtów w których nie ma zera */
        9:  336:			slen += 16,
        -:  337:
        9:  338:			(val1 += *cdat++ * MSN_H32XX_2), (val1 = MSX_ROTL32(val1, 13)), (val1 *= MSN_H32XX_1),
        9:  339:			(val2 += *cdat++ * MSN_H32XX_2), (val2 = MSX_ROTL32(val2, 13)), (val2 *= MSN_H32XX_1),
        9:  340:			(val3 += *cdat++ * MSN_H32XX_2), (val3 = MSX_ROTL32(val3, 13)), (val3 *= MSN_H32XX_1),
        9:  341:			(val4 += *cdat++ * MSN_H32XX_2), (val4 = MSX_ROTL32(val4, 13)), (val4 *= MSN_H32XX_1),
        -:  342:
        -:  343:			/* trzeba niestety szukać zer w następnych elementach przed kolejną iteracją */
        9:  344:			nbit = msf_hash_mbs_32s8b0_check( cdat );
        -:  345:		
       27:  346:		hash = MSX_ROTL32( val1, 1  ) + MSX_ROTL32( val2, 7  ) +
       18:  347:		       MSX_ROTL32( val3, 12 ) + MSX_ROTL32( val4, 18 );
        -:  348:	}
        -:  349:	else
        7:  350:		hash = MSD_HASH_SEED + MSN_H32XX_5;
        -:  351:
        -:  352:	/* długość ciągu już jest znana */
       16:  353:	slen += nbit - 1;
       16:  354:	hash += slen;
        -:  355:
        -:  356:	/* przejmuj odpadki, liczba podniesiona względem oryginału ze względu wartości nbit */
       16:  357:	if( nbit > 12 )
        4:  358:		(hash += *cdat++ * MSN_H32XX_3), (hash = MSX_ROTL32(hash, 17) * MSN_H32XX_4),
        4:  359:		(hash += *cdat++ * MSN_H32XX_3), (hash = MSX_ROTL32(hash, 17) * MSN_H32XX_4),
        4:  360:		(hash += *cdat++ * MSN_H32XX_3), (hash = MSX_ROTL32(hash, 17) * MSN_H32XX_4), (nbit -= 12);
       12:  361:	else if( nbit > 8 )
        4:  362:		(hash += *cdat++ * MSN_H32XX_3), (hash = MSX_ROTL32(hash, 17) * MSN_H32XX_4),
        4:  363:		(hash += *cdat++ * MSN_H32XX_3), (hash = MSX_ROTL32(hash, 17) * MSN_H32XX_4), (nbit -= 8);
        8:  364:	else if( nbit > 4 )
        4:  365:		(hash += *cdat++ * MSN_H32XX_3), (hash = MSX_ROTL32(hash, 17) * MSN_H32XX_4), (nbit -= 4);
        -:  366:
       16:  367:	adat = (const uint8_t*)cdat;
       16:  368:	switch( nbit )
        -:  369:	{
        4:  370:		case 4: (hash += *adat++ * MSN_H32XX_5), (hash = MSX_ROTL32(hash, 11) * MSN_H32XX_1);
        8:  371:		case 3: (hash += *adat++ * MSN_H32XX_5), (hash = MSX_ROTL32(hash, 11) * MSN_H32XX_1);
       12:  372:		case 2: (hash += *adat++ * MSN_H32XX_5), (hash = MSX_ROTL32(hash, 11) * MSN_H32XX_1);
        -:  373:	}
        -:  374:
       16:  375:	hash ^= hash >> 15;
       16:  376:	hash *= MSN_H32XX_2;
       16:  377:	hash ^= hash >> 13;
       16:  378:	hash *= MSN_H32XX_3;
       16:  379:	hash ^= hash >> 16;
        -:  380:
       16:  381:	return hash;
        -:  382:}
        -:  383:
        -:  384:/* ================================================================================================================== */
        -:  385:
       32:  386:uint64_t ms_hash_mbs_64_xxhash( const char *data )
        -:  387:{
       32:  388:	uint64_t hash = 0;
       32:  389:	size_t   slen = 0;
        -:  390:	size_t   nbit;
        -:  391:
       32:  392:	const uint64_t *cdat = (const uint64_t*)data;
        -:  393:	const uint32_t *vdat;
        -:  394:	const uint8_t  *adat;
        -:  395:
       32:  396:	uint64_t val1 = MSD_HASH_SEED + MSN_H64XX_1 + MSN_H64XX_2;
       32:  397:	uint64_t val2 = MSD_HASH_SEED + MSN_H64XX_2;
       32:  398:	uint64_t val3 = MSD_HASH_SEED;
       32:  399:	uint64_t val4 = MSD_HASH_SEED - MSN_H64XX_1;
        -:  400:
       32:  401:	assert( data );
        -:  402:
       32:  403:	nbit = msf_hash_mbs_64s8b0_check( cdat );
       32:  404:	if( !nbit )
        -:  405:	{
       27:  406:		while( !nbit )
        9:  407:			slen += 32,
        -:  408:
        9:  409:			(val1 += *cdat++ * MSN_H64XX_2), (val1 = MSX_ROTL64(val1, 31)), (val1 *= MSN_H64XX_1),
        9:  410:			(val2 += *cdat++ * MSN_H64XX_2), (val2 = MSX_ROTL64(val2, 31)), (val2 *= MSN_H64XX_1),
        9:  411:			(val3 += *cdat++ * MSN_H64XX_2), (val3 = MSX_ROTL64(val3, 31)), (val3 *= MSN_H64XX_1),
        9:  412:			(val4 += *cdat++ * MSN_H64XX_2), (val4 = MSX_ROTL64(val4, 31)), (val4 *= MSN_H64XX_1),
        -:  413:
        -:  414:			/* trzeba niestety szukać zer w następnych elementach przed kolejną iteracją */         
        9:  415:			nbit = msf_hash_mbs_64s8b0_check( cdat );
        -:  416:		
       27:  417:		hash = MSX_ROTL64( val1, 1  ) + MSX_ROTL64( val2, 7  ) +
       18:  418:		       MSX_ROTL64( val3, 12 ) + MSX_ROTL64( val4, 18 );
        -:  419:
        9:  420:		hash = msf_hash_mix64_value( hash, val1 );
        9:  421:		hash = msf_hash_mix64_value( hash, val2 );
        9:  422:		hash = msf_hash_mix64_value( hash, val3 );
        9:  423:		hash = msf_hash_mix64_value( hash, val4 );
        -:  424:	}
        -:  425:	else
       23:  426:		hash = MSD_HASH_SEED + MSN_H64XX_5;
        -:  427:
        -:  428:	/* długość ciągu już jest znana */
       32:  429:	slen += nbit - 1;
       32:  430:	hash += slen;
        -:  431:
        -:  432:	/* odpadki 64, 32 i 8 bajtowe */
       32:  433:	if( nbit > 24 )
        8:  434:		hash = msf_hash_mix64_char64( hash, *cdat++ ),
        8:  435:		hash = msf_hash_mix64_char64( hash, *cdat++ ),
        8:  436:		hash = msf_hash_mix64_char64( hash, *cdat++ ), nbit -= 24;
       24:  437:	else if( nbit > 16 )
        8:  438:		hash = msf_hash_mix64_char64( hash, *cdat++ ),
        8:  439:		hash = msf_hash_mix64_char64( hash, *cdat++ ), nbit -= 16;
       16:  440:	else if( nbit > 8 )
        8:  441:		hash = msf_hash_mix64_char64( hash, *cdat++ ), nbit -= 8;
        -:  442:
       32:  443:	vdat = (const uint32_t*)cdat;
       32:  444:	if( nbit > 4 )
       16:  445:		(hash ^= *vdat++ * MSN_H64XX_1), (hash = MSX_ROTL64(hash, 23) * MSN_H64XX_2 + MSN_H64XX_3), (nbit -= 4);
        -:  446:
       32:  447:	adat = (const uint8_t*)vdat;
       32:  448:	switch( nbit )
        -:  449:	{
        8:  450:		case 4: (hash ^= *adat++ * MSN_H64XX_5), (hash = MSX_ROTL64(hash, 11) * MSN_H64XX_1);
       16:  451:		case 3: (hash ^= *adat++ * MSN_H64XX_5), (hash = MSX_ROTL64(hash, 11) * MSN_H64XX_1);
       24:  452:		case 2: (hash ^= *adat++ * MSN_H64XX_5), (hash = MSX_ROTL64(hash, 11) * MSN_H64XX_1);
        -:  453:	}
        -:  454:
       32:  455:	hash ^= hash >> 33;
       32:  456:	hash *= MSN_H64XX_2;
       32:  457:	hash ^= hash >> 29;
       32:  458:	hash *= MSN_H64XX_3;
       32:  459:	hash ^= hash >> 32;
        -:  460:
       32:  461:	return hash;
        -:  462:}
        -:  463:
        -:  464:#endif
        -:  465:#ifdef MSD_HASH_WCS_FUNCTIONS
        -:  466:
        -:  467:/* ================================================================================================================== */
        -:  468:
       17:  469:uint32_t ms_hash_wcs_32_xxhash( const wchar_t *data )
        -:  470:{
       17:  471:	uint32_t hash = 0;
        -:  472:	size_t   nbit,
       17:  473:	         slen = 0;
        -:  474:
       17:  475:	const uint32_t *cdat = (const uint32_t*)data;
        -:  476:
       17:  477:	uint32_t val1 = MSD_HASH_SEED + MSN_H32XX_1 + MSN_H32XX_2;
       17:  478:	uint32_t val2 = MSD_HASH_SEED + MSN_H32XX_2;
       17:  479:	uint32_t val3 = MSD_HASH_SEED;
       17:  480:	uint32_t val4 = MSD_HASH_SEED - MSN_H32XX_1;
        -:  481:
       17:  482:	assert( data );
        -:  483:
        -:  484:	/* wersja dla 2 bajtowego rozmiaru wchar_t */
        -:  485:	if( sizeof(wchar_t) == 2 )
        -:  486:	{
        -:  487:		const uint8_t *adat;
        -:  488:
        -:  489:		nbit = msf_hash_mbs_32s16b0_check( cdat );
        -:  490:		if( !nbit )
        -:  491:		{
        -:  492:			while( !nbit )
        -:  493:				slen += 16,
        -:  494:
        -:  495:				(val1 += *cdat++ * MSN_H32XX_2), (val1 = MSX_ROTL32(val1, 13)), (val1 *= MSN_H32XX_1),
        -:  496:				(val2 += *cdat++ * MSN_H32XX_2), (val2 = MSX_ROTL32(val2, 13)), (val2 *= MSN_H32XX_1),
        -:  497:				(val3 += *cdat++ * MSN_H32XX_2), (val3 = MSX_ROTL32(val3, 13)), (val3 *= MSN_H32XX_1),
        -:  498:				(val4 += *cdat++ * MSN_H32XX_2), (val4 = MSX_ROTL32(val4, 13)), (val4 *= MSN_H32XX_1),
        -:  499:
        -:  500:				nbit = msf_hash_mbs_32s16b0_check( cdat );
        -:  501:
        -:  502:			hash = MSX_ROTL32( val1, 1  ) + MSX_ROTL32( val2, 7  ) +
        -:  503:			       MSX_ROTL32( val3, 12 ) + MSX_ROTL32( val4, 18 );
        -:  504:		}
        -:  505:		else
        -:  506:			hash = MSD_HASH_SEED + MSN_H32XX_5;
        -:  507:
        -:  508:		/* wartość nbit trzeba pomnożyć przez 2 z racji rozmiaru wchar_t */
        -:  509:		slen += nbit ? (nbit - 1) << 1 : 0;
        -:  510:		hash += slen;
        -:  511:
        -:  512:		/* liczba podzielona przez 2 względem wersji mbs z racji rozmiaru wchar_t */
        -:  513:		if( nbit > 6 )
        -:  514:			(hash += *cdat++ * MSN_H32XX_3), (hash = MSX_ROTL32(hash, 17) * MSN_H32XX_4),
        -:  515:			(hash += *cdat++ * MSN_H32XX_3), (hash = MSX_ROTL32(hash, 17) * MSN_H32XX_4),
        -:  516:			(hash += *cdat++ * MSN_H32XX_3), (hash = MSX_ROTL32(hash, 17) * MSN_H32XX_4), (nbit -= 6);
        -:  517:		if( nbit > 4 )
        -:  518:			(hash += *cdat++ * MSN_H32XX_3), (hash = MSX_ROTL32(hash, 17) * MSN_H32XX_4),
        -:  519:			(hash += *cdat++ * MSN_H32XX_3), (hash = MSX_ROTL32(hash, 17) * MSN_H32XX_4), (nbit -= 4);
        -:  520:		if( nbit > 2 )
        -:  521:			(hash += *cdat++ * MSN_H32XX_3), (hash = MSX_ROTL32(hash, 17) * MSN_H32XX_4), (nbit -= 2);
        -:  522:
        -:  523:		/* tylko dwa odpadki 8 bitowe z racji tego, że 0 zajmuje całe 16 bitów */
        -:  524:		adat = (const uint8_t*)cdat;
        -:  525:		if( nbit == 2 )
        -:  526:			(hash += *adat++ * MSN_H32XX_5), (hash = MSX_ROTL32(hash, 11) * MSN_H32XX_1),
        -:  527:			(hash += *adat++ * MSN_H32XX_5), (hash = MSX_ROTL32(hash, 11) * MSN_H32XX_1);
        -:  528:	}
        -:  529:	/* wersja dla 4 bajtowego rozmiaru wchar_t */
        -:  530:	else if( sizeof(wchar_t) == 4 )
        -:  531:	{
       17:  532:		nbit = msf_hash_mbs_32s32b0_check( cdat );
       17:  533:		if( !nbit )
        -:  534:		{
       92:  535:			while( !nbit )
       60:  536:				slen += 16,
        -:  537:
       60:  538:				(val1 += *cdat++ * MSN_H32XX_2), (val1 = MSX_ROTL32(val1, 13)), (val1 *= MSN_H32XX_1),
       60:  539:				(val2 += *cdat++ * MSN_H32XX_2), (val2 = MSX_ROTL32(val2, 13)), (val2 *= MSN_H32XX_1),
       60:  540:				(val3 += *cdat++ * MSN_H32XX_2), (val3 = MSX_ROTL32(val3, 13)), (val3 *= MSN_H32XX_1),
       60:  541:				(val4 += *cdat++ * MSN_H32XX_2), (val4 = MSX_ROTL32(val4, 13)), (val4 *= MSN_H32XX_1),
        -:  542:
       60:  543:				nbit = msf_hash_mbs_32s32b0_check( cdat );
        -:  544:
       48:  545:			hash = MSX_ROTL32( val1, 1  ) + MSX_ROTL32( val2, 7  ) +
       32:  546:			       MSX_ROTL32( val3, 12 ) + MSX_ROTL32( val4, 18 );
        -:  547:		}
        -:  548:		else
        1:  549:			hash = MSD_HASH_SEED + MSN_H32XX_5;
        -:  550:
        -:  551:		/* wartość nbit trzeba pomnożyć przez 4 z racji rozmiaru wchar_t */
       17:  552:		slen += nbit ? (nbit - 1) << 2 : 0;
       17:  553:		hash += slen;
        -:  554:
        -:  555:		/* liczba podzielona przez 4 względem wersji mbs z racji rozmiaru wchar_t */
       17:  556:		if( nbit > 3 )
        5:  557:			hash += *cdat++ * MSN_H32XX_3,
        5:  558:			hash  = MSX_ROTL32( hash, 17 ) * MSN_H32XX_4,
        5:  559:			nbit -= 1;
       17:  560:		if( nbit > 2 )
        9:  561:			hash += *cdat++ * MSN_H32XX_3,
        9:  562:			hash  = MSX_ROTL32( hash, 17 ) * MSN_H32XX_4,
        9:  563:			nbit -= 1;
       17:  564:		if( nbit > 1 )
       13:  565:			hash += *cdat++ * MSN_H32XX_3,
       13:  566:			hash  = MSX_ROTL32( hash, 17 ) * MSN_H32XX_4;
        -:  567:
        -:  568:		/* brak odpadków 8 bitowych, ponieważ 0 zajmuje całe 32 bity! */
        -:  569:	}
        -:  570:	/* czy wchar_t może mieć inne rozmiary? */
        -:  571:
       17:  572:	hash ^= hash >> 15;
       17:  573:	hash *= MSN_H32XX_2;
       17:  574:	hash ^= hash >> 13;
       17:  575:	hash *= MSN_H32XX_3;
       17:  576:	hash ^= hash >> 16;
        -:  577:
       17:  578:	return hash;
        -:  579:}
        -:  580:
        -:  581:/* ================================================================================================================== */
        -:  582:
       33:  583:uint64_t ms_hash_wcs_64_xxhash( const wchar_t *data )
        -:  584:{
       33:  585:	uint64_t hash = 0;
       33:  586:	size_t   slen = 0;
        -:  587:	size_t   nbit;
        -:  588:
       33:  589:	const uint64_t *cdat = (const uint64_t*)data;
        -:  590:	const uint32_t *vdat;
        -:  591:
       33:  592:	uint64_t val1 = MSD_HASH_SEED + MSN_H64XX_1 + MSN_H64XX_2;
       33:  593:	uint64_t val2 = MSD_HASH_SEED + MSN_H64XX_2;
       33:  594:	uint64_t val3 = MSD_HASH_SEED;
       33:  595:	uint64_t val4 = MSD_HASH_SEED - MSN_H64XX_1;
        -:  596:
       33:  597:	assert( data );
        -:  598:
        -:  599:	/* wersja dla 2 bajtowego rozmiaru wchar_t */
        -:  600:	if( sizeof(wchar_t) == 2 )
        -:  601:	{
        -:  602:		const uint8_t  *adat;
        -:  603:
        -:  604:		nbit = msf_hash_mbs_64s16b0_check( cdat );
        -:  605:		if( !nbit )
        -:  606:		{
        -:  607:			while( !nbit )
        -:  608:				slen += 32,
        -:  609:
        -:  610:				(val1 += *cdat++ * MSN_H64XX_2), (val1 = MSX_ROTL64(val1, 31)), (val1 *= MSN_H64XX_1),
        -:  611:				(val2 += *cdat++ * MSN_H64XX_2), (val2 = MSX_ROTL64(val2, 31)), (val2 *= MSN_H64XX_1),
        -:  612:				(val3 += *cdat++ * MSN_H64XX_2), (val3 = MSX_ROTL64(val3, 31)), (val3 *= MSN_H64XX_1),
        -:  613:				(val4 += *cdat++ * MSN_H64XX_2), (val4 = MSX_ROTL64(val4, 31)), (val4 *= MSN_H64XX_1),
        -:  614:
        -:  615:				nbit = msf_hash_mbs_64s16b0_check( cdat );
        -:  616:			
        -:  617:			hash = MSX_ROTL64( val1, 1  ) + MSX_ROTL64( val2, 7  ) +
        -:  618:			       MSX_ROTL64( val3, 12 ) + MSX_ROTL64( val4, 18 );
        -:  619:
        -:  620:			hash = msf_hash_mix64_value( hash, val1 );
        -:  621:			hash = msf_hash_mix64_value( hash, val2 );
        -:  622:			hash = msf_hash_mix64_value( hash, val3 );
        -:  623:			hash = msf_hash_mix64_value( hash, val4 );
        -:  624:		}
        -:  625:		else
        -:  626:			hash = MSD_HASH_SEED + MSN_H64XX_5;
        -:  627:
        -:  628:		slen += (nbit - 1) << 1;
        -:  629:		hash += slen;
        -:  630:
        -:  631:		/* liczba podzielona przez 2 względem wersji mbs z racji rozmiaru wchar_t */
        -:  632:		if( nbit > 12 )
        -:  633:			hash = msf_hash_mix64_char64( hash, *cdat++ ),
        -:  634:			hash = msf_hash_mix64_char64( hash, *cdat++ ),
        -:  635:			hash = msf_hash_mix64_char64( hash, *cdat++ ), nbit -= 12;
        -:  636:		if( nbit > 8 )
        -:  637:			hash = msf_hash_mix64_char64( hash, *cdat++ ),
        -:  638:			hash = msf_hash_mix64_char64( hash, *cdat++ ), nbit -= 8;
        -:  639:		if( nbit > 4 )
        -:  640:			hash = msf_hash_mix64_char64( hash, *cdat++ ), nbit -= 4;
        -:  641:
        -:  642:		vdat = (const uint32_t*)cdat;
        -:  643:		if( nbit > 2 )
        -:  644:			(hash ^= *vdat++ * MSN_H64XX_1), (hash = MSX_ROTL64(hash, 23) * MSN_H64XX_2 + MSN_H64XX_3), (nbit -= 2);
        -:  645:
        -:  646:		/* tylko dwa odpadki 8 bitowe z racji tego, że 0 zajmuje całe 16 bitów */
        -:  647:		adat = (const uint8_t*)vdat;
        -:  648:		if( nbit == 2 )
        -:  649:			(hash ^= *adat++ * MSN_H64XX_5), (hash = MSX_ROTL64(hash, 11) * MSN_H64XX_1),
        -:  650:			(hash ^= *adat++ * MSN_H64XX_5), (hash = MSX_ROTL64(hash, 11) * MSN_H64XX_1);
        -:  651:	}
        -:  652:	/* wersja dla 4 bajtowego rozmiaru wchar_t */
        -:  653:	else if( sizeof(wchar_t) == 4 )
        -:  654:	{
       33:  655:		nbit = msf_hash_mbs_64s32b0_check( cdat );
       33:  656:		if( !nbit )
        -:  657:		{
      148:  658:			while( !nbit )
       84:  659:				slen += 32,
        -:  660:
       84:  661:				(val1 += *cdat++ * MSN_H64XX_2), (val1 = MSX_ROTL64(val1, 31)), (val1 *= MSN_H64XX_1),
       84:  662:				(val2 += *cdat++ * MSN_H64XX_2), (val2 = MSX_ROTL64(val2, 31)), (val2 *= MSN_H64XX_1),
       84:  663:				(val3 += *cdat++ * MSN_H64XX_2), (val3 = MSX_ROTL64(val3, 31)), (val3 *= MSN_H64XX_1),
       84:  664:				(val4 += *cdat++ * MSN_H64XX_2), (val4 = MSX_ROTL64(val4, 31)), (val4 *= MSN_H64XX_1),
        -:  665:
       84:  666:				nbit = msf_hash_mbs_64s32b0_check( cdat );
        -:  667:			
       96:  668:			hash = MSX_ROTL64( val1, 1  ) + MSX_ROTL64( val2, 7  ) +
       64:  669:			       MSX_ROTL64( val3, 12 ) + MSX_ROTL64( val4, 18 );
        -:  670:
       32:  671:			hash = msf_hash_mix64_value( hash, val1 );
       32:  672:			hash = msf_hash_mix64_value( hash, val2 );
       32:  673:			hash = msf_hash_mix64_value( hash, val3 );
       32:  674:			hash = msf_hash_mix64_value( hash, val4 );
        -:  675:		}
        -:  676:		else
        1:  677:			hash = MSD_HASH_SEED + MSN_H64XX_5;
        -:  678:
       33:  679:		slen += (nbit - 1) << 2;
       33:  680:		hash += slen;
        -:  681:
        -:  682:		/* liczba podzielona przez 4 względem wersji mbs z racji rozmiaru wchar_t */
       33:  683:		if( nbit > 6 )
        8:  684:			hash = msf_hash_mix64_char64( hash, *cdat++ ),
        8:  685:			hash = msf_hash_mix64_char64( hash, *cdat++ ),
        8:  686:			hash = msf_hash_mix64_char64( hash, *cdat++ ), nbit -= 6;
       33:  687:		if( nbit > 4 )
        8:  688:			hash = msf_hash_mix64_char64( hash, *cdat++ ),
        8:  689:			hash = msf_hash_mix64_char64( hash, *cdat++ ), nbit -= 4;
       33:  690:		if( nbit > 2 )
        9:  691:			hash = msf_hash_mix64_char64( hash, *cdat++ ), nbit -= 2;
        -:  692:
       33:  693:		vdat = (const uint32_t*)cdat;
       33:  694:		if( nbit == 2 )
       17:  695:			hash ^= *vdat++ * MSN_H64XX_1,
       17:  696:			hash  = MSX_ROTL64( hash, 23 ) * MSN_H64XX_2 + MSN_H64XX_3;
        -:  697:
        -:  698:		/* brak odpadków 8 bitowych, ponieważ 0 zajmuje całe 32 bity! */
        -:  699:	}
        -:  700:	/* czy wchar_t może mieć inne rozmiary? */
        -:  701:
       33:  702:	hash ^= hash >> 33;
       33:  703:	hash *= MSN_H64XX_2;
       33:  704:	hash ^= hash >> 29;
       33:  705:	hash *= MSN_H64XX_3;
       33:  706:	hash ^= hash >> 32;
        -:  707:
       33:  708:	return hash;
        -:  709:}
        -:  710:
        -:  711:#endif
        -:  712:
        -:  713:/* ================================================================================================================== */
        -:  714:
      328:  715:INLINE static uint64_t msf_hash_mix64_value( uint64_t hash, uint64_t value )
        -:  716:{
      328:  717:	value *= MSN_H64XX_2;
      328:  718:	value  = MSX_ROTL64( value, 31 );
      328:  719:	value *= MSN_H64XX_1;
      328:  720:	hash  ^= value;
        -:  721:
      328:  722:	return hash * MSN_H64XX_1 + MSN_H64XX_4;
        -:  723:}
        -:  724:
        -:  725:/* ================================================================================================================== */
        -:  726:
      194:  727:INLINE static uint64_t msf_hash_mix64_char64( uint64_t hash, uint64_t c64 )
        -:  728:{
      194:  729:	c64  *= MSN_H64XX_2;
      194:  730:	c64   = MSX_ROTL64( c64, 31 );
      194:  731:	c64  *= MSN_H64XX_1;
      194:  732:	hash ^= c64;
        -:  733:
      194:  734:	return MSX_ROTL64( hash, 27 ) * MSN_H64XX_1 + MSN_H64XX_4;
        -:  735:}
        -:  736:
        -:  737:/* ================================================================================================================== */
        -:  738:
       25:  739:INLINE static size_t msf_hash_mbs_32s8b0_check( const uint32_t *data )
        -:  740:{
        -:  741:	size_t nbit;
        -:  742:
       25:  743:	if( (nbit = MSX_FIND8B0IN32B(data[0])) != 0 )
        4:  744:		return nbit;
       21:  745:	if( (nbit = MSX_FIND8B0IN32B(data[1])) != 0 )
        4:  746:		return 4 + nbit;
       17:  747:	if( (nbit = MSX_FIND8B0IN32B(data[2])) != 0 )
        4:  748:		return 8 + nbit;
       13:  749:	if( (nbit = MSX_FIND8B0IN32B(data[3])) != 0 )
        4:  750:		return 12 + nbit;
        -:  751:	
        9:  752:	return 0;
        -:  753:}
        -:  754:
        -:  755:/* ================================================================================================================== */
        -:  756:
       41:  757:INLINE static size_t msf_hash_mbs_64s8b0_check( const uint64_t *data )
        -:  758:{
        -:  759:	size_t nbit;
        -:  760:
       41:  761:	if( (nbit = MSX_FIND8B0IN64B(data[0])) != 0 )
        8:  762:		return nbit;
       33:  763:	if( (nbit = MSX_FIND8B0IN64B(data[1])) != 0 )
        8:  764:		return 8 + nbit;
       25:  765:	if( (nbit = MSX_FIND8B0IN64B(data[2])) != 0 )
        8:  766:		return 16 + nbit;
       17:  767:	if( (nbit = MSX_FIND8B0IN64B(data[3])) != 0 )
        8:  768:		return 24 + nbit;
        -:  769:
        9:  770:	return 0;
        -:  771:}
        -:  772:
        -:  773:/* ================================================================================================================== */
        -:  774:
        -:  775:INLINE static size_t msf_hash_mbs_64s16b0_check( const uint64_t *data )
        -:  776:{
        -:  777:	size_t nbit;
        -:  778:
        -:  779:	if( (nbit = MSX_FIND16B0IN64B(data[0])) != 0 )
        -:  780:		return nbit;
        -:  781:	if( (nbit = MSX_FIND16B0IN64B(data[1])) != 0 )
        -:  782:		return 4 + nbit;
        -:  783:	if( (nbit = MSX_FIND16B0IN64B(data[2])) != 0 )
        -:  784:		return 8 + nbit;
        -:  785:	if( (nbit = MSX_FIND16B0IN64B(data[3])) != 0 )
        -:  786:		return 12 + nbit;
        -:  787:
        -:  788:	return 0;
        -:  789:}
        -:  790:
        -:  791:/* ================================================================================================================== */
        -:  792:
      117:  793:INLINE static size_t msf_hash_mbs_64s32b0_check( const uint64_t *data )
        -:  794:{
        -:  795:	size_t nbit;
        -:  796:
      117:  797:	if( (nbit = MSX_FIND32B0IN64B(data[0])) != 0 )
        8:  798:		return nbit;
      109:  799:	if( (nbit = MSX_FIND32B0IN64B(data[1])) != 0 )
        9:  800:		return 2 + nbit;
      100:  801:	if( (nbit = MSX_FIND32B0IN64B(data[2])) != 0 )
        8:  802:		return 4 + nbit;
       92:  803:	if( (nbit = MSX_FIND32B0IN64B(data[3])) != 0 )
        8:  804:		return 6 + nbit;
        -:  805:
       84:  806:	return 0;
        -:  807:}
        -:  808:
        -:  809:/* ================================================================================================================== */
        -:  810:
        -:  811:INLINE static size_t msf_hash_mbs_32s16b0_check( const uint32_t *data )
        -:  812:{
        -:  813:	size_t nbit;
        -:  814:
        -:  815:	if( (nbit = MSX_FIND16B0IN32B(data[0])) != 0 )
        -:  816:		return nbit;
        -:  817:	if( (nbit = MSX_FIND16B0IN32B(data[1])) != 0 )
        -:  818:		return 2 + nbit;
        -:  819:	if( (nbit = MSX_FIND16B0IN32B(data[2])) != 0 )
        -:  820:		return 4 + nbit;
        -:  821:	if( (nbit = MSX_FIND16B0IN32B(data[3])) != 0 )
        -:  822:		return 6 + nbit;
        -:  823:	
        -:  824:	return 0;
        -:  825:}
        -:  826:
        -:  827:/* ================================================================================================================== */
        -:  828:
       77:  829:INLINE static size_t msf_hash_mbs_32s32b0_check( const uint32_t *data )
        -:  830:{
       77:  831:	if( !data[0] )
        4:  832:		return 1;
       73:  833:	if( !data[1] )
        4:  834:		return 2;
       69:  835:	if( !data[2] )
        4:  836:		return 3;
       65:  837:	if( !data[3] )
        5:  838:		return 4;
        -:  839:	
       60:  840:	return 0;
        -:  841:}
        -:  842:
        -:  843:#ifdef MSD_COMPILER_MSC
        -:  844:	__pragma( warning(pop) )
        -:  845:#endif
