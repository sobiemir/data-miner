<data>
	<!-- stałe predefiniowane używane podczas pobierania symboli -->
	<predefined>
		<macro name="MSD_HASH_MBS_FUNCTIONS" />
		<macro name="MSD_HASH_WCS_FUNCTIONS" />
		<macro name="MSD_HASH_MURMUR" />
		<macro name="MSD_HASH_JOAAT" />
		<macro name="MSD_HASH_FNV" />
		<macro name="MSD_HASH_SDBM" />
		<macro name="MSD_HASH_DJB" />
		<macro name="MSD_HASH_XXHASH" />
		
		<macro name="IGRET" />
		<macro name="IGVAR" />
		
		<macro name="MSD_SYSTEM_LINUX" />
		<macro name="MSD_COMPILER_GNUC" />

		<macro name="INLINE">inline</macro>

		<macro name="TEST_PREDEFINED">
			<param>_x</param>
			<param>_y</param>
			<content>ms_{:_x}_get_{:_y}</content>
		</macro>
	</predefined>

	<start name="ENTRY" />

	<rules>

		<rule name="ENTRY">
			<function name="LOOP">
				<rule>PREPARE_TEXT</rule>
			</function>
			<function name="REWIND">
				<to>0</to>
			</function>
		</rule>

		<rule name="PREPARE_TEXT">
			<function name="SEEK_UNTIL_ONE_OF">
				<char value="/">0</char>
				<char value='"'>0</char>
				<char value="'">0</char>
				<else>0</else>
			</function>
		</rule>

	</steps>

</data>


{

		// Punkt wejściowy
		"ENTRY": [
			["LOOP",
				"PREPARE_TEXT"
			],
			["REWIND",
				0
			]
		],

		// Przygotowywanie tekstu pod parsowanie
		"PREPARE_TEXT": [
			["SEEK_UNTIL_ONE_OF", {
					"/":  false,
					"\"": false,
					"'":  false
				},
				false
			],
			["CHAR_CHECK", {
					"/":  "COMMENT",
					"\"": "SKIP_CONTENT_DOUBLE",
					"'":  "SKIP_CONTENT_SINGLE"
				},
				false
			]
		],

		// Usuwa ciągi znaków zapisane w apostrofie
		"SKIP_CONTENT_DOUBLE": [
			- ___
				- REPLACE_UNTIL_ESCAPE
				- '"'
				- " "
				- TRUE
				- \
		]
		
		# Usuwa ciągi znaków zapisane w apostrofie
		SKIP_CONTENT_SINGLE:
			- ___
				- REPLACE_UNTIL_ESCAPE
				- "'"
				- " "
				- TRUE
				- \

		# Wykrywa typ komentarza
		COMMENT:
			- ___
				- CHAR
				-    / : COMMENT_LINE_START
					'*': COMMENT_BLOCK_START
				- FALSE

		# Początek komentarza blokowego
		COMMENT_BLOCK_START:
			- ___
				- GROUP
				- COMMENT_BLOCK
			- ___
				- SEEK
				- -2
			- ___
				- REPLACE_MANY
				- 2
				- " "
				- FALSE
			- ___
				- EXECUTE
				- COMMENT_BLOCK
			- ___
				- GROUP
				- FALSE

		# Komentarz blokowy
		COMMENT_BLOCK:
			- ___
				- REPLACE_UNTIL_ONE_OF
				-   "\n" : FALSE
					"*" :  FALSE
				- " "
				- TRUE
			- ___
				- NEXT
				- "*"
				- COMMENT_BLOCK_END_PREPARE
				- FALSE
			- ___
				- SEEK_GET
				- 1
			- ___
				- EXECUTE
				- COMMENT_BLOCK

		# Przygotowanie do zakończenia komentarza blokowego
		COMMENT_BLOCK_END_PREPARE:
			- ___
				- NEXT
				- /
				- COMMENT_BLOCK_END
				- FALSE
			- ___
				- SEEK
				- -1
			- ___
				- REPLACE
				- " "
				- TRUE
			- ___
				- EXECUTE
				- COMMENT_BLOCK

		# 
		# Zakończenie komentarza blokowego.
		# Podczas zakończenia komentarza blokowego parser musi wyczyścić jego zakończenie, czyli */.
		# Po wykonaniu tego, reguła wraca do reguły z której została wywołana.
		# ---------------------------------------------------------------------------------------------
		COMMENT_BLOCK_END:
			- ___
				- SEEK
				- -2
			- ___
				- REPLACE_MANY
				- 2
				- " "
				- FALSE

		# 
		# Rozpoczęcie komentarza liniowego.
		# Po wykryciu komentarza parser musi wyczyścić również sam początek, czyli znaki //.
		# Po wykonaniu tej czynnności, przechodzi do kroku głównego pobierania komentarza.
		# ---------------------------------------------------------------------------------------------
		COMMENT_LINE_START:
			- ___
				- GROUP
				- COMMENT_LINE
			- ___
				- SEEK
				- -1
			- ___
				- REPLACE
				- " "
				- FALSE
			- ___
				- EXECUTE
				- COMMENT_LINE
			- ___
				- GROUP
				- FALSE

		# 
		# Kontynuacja komentarza liniowego po znaku ucieczki (wieloliniowy komentarz liniowy)
		# Jest to możliwe dzięki zastosowaniu takiego sposobu:
		#
		# // komentarz liniowy \
		#    jednak w dwóch liniach
		#
		# Taki komentarz, choć w wielu liniach, traktowany będzie nadal jako liniowy.
		# ---------------------------------------------------------------------------------------------
		COMMENT_LINE_CONTINUE:
			- ___
				- SEEK
				- -1
			- ___
				- WRITE_FROM_STREAM
			- ___
				- EXECUTE
				- COMMENT_LINE

		# 
		# Komentarz liniowy.
		# Szuka znaku końca linii lub znaku ucieczki, pobierając komentarz do grupy i zamieniając go
		# pustymi znakami.
		# Wyszukuje tylko linuksowych znaków końca linii.
		# ---------------------------------------------------------------------------------------------
		COMMENT_LINE:
			- ___
				- SEEK
				- -2
			- ___
				- REPLACE
				- " "
				- FALSE
			- ___
				- SEEK
				- 1
			- ___
				- REPLACE_UNTIL_ONE_OF
				-   \  : FALSE
				   "\n": FALSE
				- " "
				- TRUE
			- ___
				- NEXT
				- \
				- FALSE
				- ''
			- ___
				- REPLACE
				- " "
				- FALSE
			- ___
				- NEXT
				- "\n"
				- COMMENT_LINE_CONTINUE
				- FALSE
			- ___
				- WRITE
				- \
			- ___
				- EXECUTE
				- COMMENT_LINE

		CAPTURE_DATA:
			- ___
				- WHITESPACE_ESCAPE
}
