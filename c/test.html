

#<struct Struct::Comment Begin=4, End=4, Start=-1, Type=4, Text="komentarz blokowy ale w linii">

#<struct Struct::Comment Begin=6, End=7, Start=-1, Type=2, Text="test komentarza w linii\njednakowoż rozbitego na dwie części">

#<struct Struct::Comment Begin=10, End=10, Start=-1, Type=4, Text="zmyłka - może">

#<struct Struct::Comment Begin=10, End=10, Start=-1, Type=4, Text="bez inicjalizatora">

#<struct Struct::Comment Begin=10, End=10, Start=-1, Type=4, Text="dużo komentarzy w linii">

#<struct Struct::Comment Begin=18, End=18, Start=-1, Type=1, Text="kolejny komentarz lecz tym razem sam">

#<struct Struct::Comment Begin=22, End=85, Start=-1, Type=3, Text="\nDodaje do tablicy elementy z podanego zakresu, kopiując je z innej tablicy.\n\nKontrola zakresu uniemożliwia podanie indeksu w zmiennej <tt>offset</tt> oraz rozmiaru zakresu przewyższającego\nrzeczywistą ilość zapisanych elementów w tablicy.\n\nFunkcja działa w podobny sposób jak funkcja <see>ms_array_insert_values</see> z dwoma różnicami.\nPierwszą jest to, że elementy kopiowane muszą być umieszczone w tablicy dynamicznej, drugą zaś, że\nnie można podać indeksu od którego wartości będą wstawiane.\n\nPodczas łączenia tablic elementy wstawiane są zawsze na samym końcu tablicy przekazanej w zmiennej <tt>dst</tt>.\nW przypadku podania wartości 0 do zmiennej <tt>count</tt>, ilość kopiowanych elementów jest obliczana\nautomatycznie i przyjmuje wartość równą ilości pozostałych elementów do końca tablicy, licząc od\nwartości zmiennej <tt>offset</tt>.\n\n<code>\n    int      list[] = { 0, 1, 2, 3, 4, 5, 6, 7 };\n    MS_ARRAY array1  = ms_array_return_local( sizeof(int), 8 ),\n             array2;\n    int     *elems,\n             ercode;\n    size_t   iter;\n\n    ms_array_init( &array2, sizeof(int), 8 );\n\n    if( (ercode = ms_array_insert_values(&array1, 0, list, 8)) )\n        printf( \"Error! Failed to insert elements to array! Code: %d.\\n\", ercode );\n\n    if( (ercode = ms_array_join_slice(&array2, &array1, 2, 4)) )\n        printf( \"Error! Function failed with code: %d!\\n\", ercode );\n\n    // dodaj elementy od indeksu 5 do końca\n    if( (ercode = ms_array_join_slice(&array2, &array1, 5, 0)) )\n        printf( \"Error! Function failed with code: %d!\\n\", ercode );\n\n    // wypisz wszystkie wartości\n    elems = (int*)array2.Items;\n    for( iter = 0; iter < array2.Length; ++iter )\n        printf( \"Array => Index: %zu with Value: %d\\n\", iter, elems[iter] );\n\n    ms_array_free( &array1 );\n    ms_array_free( &array2 );\n</code>\n<code>\n    Array => Index: 0 with Value: 2\n    Array => Index: 1 with Value: 3\n    Array => Index: 2 with Value: 4\n    Array => Index: 3 with Value: 5\n    Array => Index: 4 with Value: 5\n    Array => Index: 5 with Value: 6\n    Array => Index: 6 with Value: 7\n</code>\n\n<param name=\"adst\">Wskaźnik na tablicę do której elementy będą wstawiane.</param>\n<param name=\"asrc\">Wskaźnik na tablicę z której elementy będą kopiowane.</param>\n<param name=\"offset\">Indeks od którego wartości mają być kopiowane.</param>\n<param name=\"count\">Ilość elementów w zakresie lub 0.</param>\n\n<returns>Kod błędu lub wartość MSEC_OK.</returns>\n\n<error>MSE_ERROR_CODES.MSEC_MEMORY_ALLOCATION</error>\n<error>MSE_ERROR_CODES.MSEC_OUT_OF_RANGE</error>\n<error>MSE_ERROR_CODES.MSEC_INVALID_ARGUMENT</error>\n">

#<struct Struct::Comment Begin=88, End=155, Start=-1, Type=3, Text="\nDodaje do tablicy elementy z podanego zakresu, kopiując je z innej tablicy.\n\nKontrola zakresu uniemożliwia podanie indeksu w zmiennej @c offset oraz rozmiaru zakresu przewyższającego\nrzeczywistą ilość zapisanych elementów w tablicy.\n\nFunkcja działa w podobny sposób jak funkcja @see ms_array_insert_values z dwoma różnicami.\nPierwszą jest to, że elementy kopiowane muszą być umieszczone w tablicy dynamicznej, drugą zaś, że\nnie można podać indeksu od którego wartości będą wstawiane.\n\nPodczas łączenia tablic elementy wstawiane są zawsze na samym końcu tablicy przekazanej w zmiennej @c dst.\nW przypadku podania wartości 0 do zmiennej @c count, ilość kopiowanych elementów jest obliczana\nautomatycznie i przyjmuje wartość równą ilości pozostałych elementów do końca tablicy, licząc od\nwartości zmiennej @c offset.\n\n@code{.c}\n\n    int      list[] = { 0, 1, 2, 3, 4, 5, 6, 7 };\n    MS_ARRAY array1  = ms_array_return_local( sizeof(int), 8 ),\n             array2;\n    int     *elems,\n             ercode;\n    size_t   iter;\n\n    ms_array_init( &array2, sizeof(int), 8 );\n\n    if( (ercode = ms_array_insert_values(&array1, 0, list, 8)) )\n        printf( \"Error! Failed to insert elements to array! Code: %d.\\n\", ercode );\n\n    if( (ercode = ms_array_join_slice(&array2, &array1, 2, 4)) )\n        printf( \"Error! Function failed with code: %d!\\n\", ercode );\n\n    // dodaj elementy od indeksu 5 do końca\n    if( (ercode = ms_array_join_slice(&array2, &array1, 5, 0)) )\n        printf( \"Error! Function failed with code: %d!\\n\", ercode );\n\n    // wypisz wszystkie wartości\n    elems = (int*)array2.Items;\n    for( iter = 0; iter < array2.Length; ++iter )\n        printf( \"Array => Index: %zu with Value: %d\\n\", iter, elems[iter] );\n\n    ms_array_free( &array1 );\n    ms_array_free( &array2 );\n\n@endcode\n@code{.unparsed}\n\n    Array => Index: 0 with Value: 2\n    Array => Index: 1 with Value: 3\n    Array => Index: 2 with Value: 4\n    Array => Index: 3 with Value: 5\n    Array => Index: 4 with Value: 5\n    Array => Index: 5 with Value: 6\n    Array => Index: 6 with Value: 7\n\n@endcode\n\n@param adst   Wskaźnik na tablicę do której elementy będą wstawiane.\n@param asrc   Wskaźnik na tablicę z której elementy będą kopiowane.\n@param offset Indeks od którego wartości mają być kopiowane.\n@param count  Ilość elementów w zakresie lub 0.\n\n@returns Kod błędu lub wartość @see MSE_ERROR_CODES.MSEC_OK.\n\n@error MSE_ERROR_CODES.MSEC_MEMORY_ALLOCATION\n@error MSE_ERROR_CODES.MSEC_OUT_OF_RANGE\n@error MSE_ERROR_CODES.MSEC_INVALID_ARGUMENT\nEND OF">

#<struct Struct::Comment Begin=158, End=235, Start=-1, Type=3, Text="\nDodaje do tablicy elementy z podanego zakresu, kopiując je z innej tablicy.\nOczywiście krótki opis funkcji może się składać z kilku linii.\nMusi być natomiast zakończony dwoma znakami nowej linii, po której odczytany zostanie TAG.\n\nDESCRIPTION:\n\n    Kontrola zakresu uniemożliwia podanie indeksu w zmiennej >>: code [offset] oraz rozmiaru zakresu przewyższającego\n    rzeczywistą ilość zapisanych elementów w tablicy.\n\n    Funkcja działa w podobny sposób jak funkcja >>: see [ms_array_insert_values] z dwoma różnicami.\n    Pierwszą jest to, że elementy kopiowane muszą być umieszczone w tablicy dynamicznej, drugą zaś, że\n    nie można podać indeksu od którego wartości będą wstawiane.\n\n    Podczas łączenia tablic elementy wstawiane są zawsze na samym końcu tablicy przekazanej w zmiennej >>: code [adst].\n    W przypadku podania wartości 0 do zmiennej >> code [count], ilość kopiowanych elementów jest obliczana\n    automatycznie i przyjmuje wartość równą ilości pozostałych elementów do końca tablicy, licząc od\n    wartości zmiennej >>: code [offset].\n\n    Jak widać, elementy po tagu oczekują na zakończenie wcięcia i rozpoczęcie kolejnego tagu.\n    Jest to prosty zabieg, dzięki któremu można w łatwy sposób kontrolować przetwarzaną treść.\n\nEXAMPLE:\n\n    int      list[] = { 0, 1, 2, 3, 4, 5, 6, 7 };\n    MS_ARRAY array1  = ms_array_return_local( sizeof(int), 8 ),\n             array2;\n    int     *elems,\n             ercode;\n    size_t   iter;\n\n    ms_array_init( &array2, sizeof(int), 8 );\n\n    if( (ercode = ms_array_insert_values(&array1, 0, list, 8)) )\n        printf( \"Error! Failed to insert elements to array! Code: %d.\\n\", ercode );\n\n    if( (ercode = ms_array_join_slice(&array2, &array1, 2, 4)) )\n        printf( \"Error! Function failed with code: %d!\\n\", ercode );\n\n    // dodaj elementy od indeksu 5 do końca\n    if( (ercode = ms_array_join_slice(&array2, &array1, 5, 0)) )\n        printf( \"Error! Function failed with code: %d!\\n\", ercode );\n\n    // wypisz wszystkie wartości\n    elems = (int*)array2.Items;\n    for( iter = 0; iter < array2.Length; ++iter )\n        printf( \"Array => Index: %zu with Value: %d\\n\", iter, elems[iter] );\n\n    ms_array_free( &array1 );\n    ms_array_free( &array2 );\n\nOUTPUT:\n\n    Array => Index: 0 with Value: 2\n    Array => Index: 1 with Value: 3\n    Array => Index: 2 with Value: 4\n    Array => Index: 3 with Value: 5\n    Array => Index: 4 with Value: 5\n    Array => Index: 5 with Value: 6\n    Array => Index: 6 with Value: 7\n\nPARAMETERS:\n\n    adst:   Wskaźnik na tablicę do której elementy będą wstawiane.\n    asrc:   Wskaźnik na tablicę z której elementy będą kopiowane.\n    offset: Indeks od którego wartości mają być kopiowane.\n    count:  Ilość elementów w zakresie lub 0.\n\nRETURNS:\n\n    Kod błędu lub wartość >>: member [MSE_ERROR_CODES.MSEC_OK].\n\nERRORS:\n\n    MSE_ERROR_CODES.MSEC_MEMORY_ALLOCATION\n    MSE_ERROR_CODES.MSEC_OUT_OF_RANGE\n    MSE_ERROR_CODES.MSEC_INVALID_ARGUMENT\n">

#<struct Struct::Comment Begin=240, End=241, Start=-1, Type=2, Text="slice elementu\nms_array_join_slice();">